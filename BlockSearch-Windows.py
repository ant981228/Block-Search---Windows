#!/usr/bin/env python3
"""
This utility searches for blocks in an index and sends them to a speech document.
"""

# Standard library imports
import csv
import ctypes
import docx
import json
import os
import re
import sys
import zipfile
from ctypes import wintypes
from contextlib import contextmanager
from dataclasses import dataclass, field
from datetime import datetime
from docx.document import Document
from docx.text.paragraph import Paragraph
from docx.enum.style import WD_STYLE_TYPE
from pathlib import Path
from tempfile import TemporaryDirectory
from typing import Dict, List, Optional, Set, Any, Tuple

# Third-party imports
import keyboard
import pythoncom
import win32com.client

# PyQt imports
from PyQt6.QtNetwork import QLocalServer, QLocalSocket

from PyQt6.QtCore import (
    Qt,
    QTimer,
    QSettings,
    QEvent,
    pyqtSignal,
    QThread,
    QObject
)

from PyQt6.QtGui import (
    QColor,
    QPalette,
    QAction,
    QActionGroup,
    QKeyEvent,
    QKeySequence,
    QIcon,
    QShortcut,
    QTextOption
)

from PyQt6.QtWidgets import (
    QApplication,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QFrame,
    QGroupBox,
    QHBoxLayout,
    QHeaderView,
    QInputDialog,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMainWindow,
    QMenu,
    QMenuBar,
    QMessageBox,
    QPushButton,
    QRadioButton,
    QScrollArea,
    QSplitter,
    QStatusBar,
    QSystemTrayIcon,
    QTabWidget,
    QTableWidget,
    QTableWidgetItem,
    QTextEdit,
    QVBoxLayout,
    QWidget,
    QMenu as QTrayMenu, 
    QComboBox,           
    QProgressBar,        
    QCheckBox
)

@dataclass
class PrefixConfig:
    """
    Represents a prefix configuration with its associated folders.
    
    Attributes:
        prefix: The search prefix (e.g., "th")
        folders: Set of folder paths associated with this prefix
    """
    prefix: str
    folders: Set[str]

@dataclass
class DocumentInfo:
    """
    Enhanced document information container with comprehensive metadata support.
    
    Attributes:
        path: Path object pointing to document location
        name: Document filename
        last_modified: Unix timestamp of last modification
        created_time: Unix timestamp of creation time
        size: File size in bytes
        search_name: Lowercase name for efficient search operations
        relative_path: Path relative to search root for folder display
        original_doc_path: Path to the original source document (if split from larger doc)
        position_in_original: Position/index in the original document
        parent_doc_name: Name of the parent document (if applicable)
        sibling_docs: List of sibling document names in document order
        is_index_generated: Whether this file was generated from the document splitter
        source_file: Original file that this document was generated from (if generated)
        source_file_mtime: Modification time of the source file when indexed
        indexed_timestamp: When this document was added to the index
    """
    path: Path
    name: str
    last_modified: float
    created_time: float
    size: int
    search_name: str = ""
    relative_path: str = ""
    original_doc_path: Optional[str] = None
    position_in_original: Optional[int] = None
    parent_doc_name: Optional[str] = None
    sibling_docs: List[str] = field(default_factory=list)
    is_index_generated: bool = False  # Whether this was generated by the document splitter
    source_file: Optional[Path] = None  # Original source file path if generated
    source_file_mtime: Optional[float] = None  # Modification time of source file when generated
    indexed_timestamp: Optional[float] = None  # When this file was added to the index

    def __post_init__(self):
        """Initialize derived attributes for optimized search operations."""
        self.search_name = self.name.lower()
        
    def needs_update(self) -> bool:
        """Check if this document needs updating based on source file changes."""
        # Skip if this is not an index-generated file or no source file available
        if not self.is_index_generated or not self.source_file or not self.source_file_mtime:
            return False
            
        # Check if source file exists
        if not self.source_file.exists():
            return False
            
        # Check if source file has been modified since indexing
        try:
            current_mtime = self.source_file.stat().st_mtime
            return current_mtime > self.source_file_mtime
        except (FileNotFoundError, PermissionError):
            return False
        
@dataclass
class ActiveDocument:
    """
    Represents an active Word document with its associated window and cursor state.
    
    Attributes:
        name: Display name of the document
        path: Full path to the document file
        window_index: Index in Word's window collection
        doc_id: Unique document identifier in Word's session
    """
    name: str
    path: str
    window_index: int
    doc_id: str

@dataclass
class PasteMode:
    """Type-safe enumeration of paste modes with clear intent."""
    CURSOR = "cursor"
    END = "end"

@dataclass
class Section:
    """
    Represents a document section with its heading and content.
    """
    title: str
    safe_title: str
    level: int
    content: List[Paragraph]
    start_index: int
    end_index: Optional[int] = None
    parent: Optional['Section'] = None
    children: List['Section'] = field(default_factory=list)
    
    def get_path_components(self) -> List[str]:
        """Get folder path components based on parent hierarchy."""
        if self.parent is None:
            return []
        else:
            # This recursively builds the path by getting parent components first
            return self.parent.get_path_components() + [self.parent.safe_title]
            
@dataclass
class SplitQueueItem:
    """
    Represents an item in the document splitting queue.
    
    Attributes:
        input_path: Path to the document to split
        template_path: Path to the template document to use
        output_dir: Destination directory for output
        heading_level: Level to split document at (1-4)
        create_zip: Whether to create a ZIP archive
        preserve_hierarchy: Whether to preserve folder hierarchy
        status: Current processing status
        progress: Current progress (0-100)
        result_path: Path to output (after processing)
        error: Error message (if any)
    """
    input_path: Path
    template_path: Path
    output_dir: Path
    heading_level: int = 3  # Default to level 3 (Heading 3)
    create_zip: bool = True
    preserve_hierarchy: bool = False
    status: str = "queued"  # queued, parsing, processing, completed, error
    progress: int = 0
    result_path: Optional[Path] = None
    error: Optional[str] = None
    
    @property
    def display_name(self) -> str:
        """Get friendly display name for the queue item."""
        return self.input_path.name


class DocxSplitterWorker(QObject):
    """Worker class to process document splitting in a background thread."""
    
    # Define signals for communication with main thread
    status_changed = pyqtSignal(int, str)  # index, status message
    progress_updated = pyqtSignal(int, int)  # index, progress percentage
    item_completed = pyqtSignal(int, Path, str)  # index, result_path, status
    item_error = pyqtSignal(int, str)  # index, error message
    all_completed = pyqtSignal()  # Signal when all items are processed
    
    def __init__(self, queue_items, start_index=0):
        super().__init__()
        self.queue_items = queue_items
        self.current_index = start_index
        self.current_splitter = None
        self.is_running = False
        self.is_cancelled = False
    
    def _status_callback(self, message):
        """Status callback for DocxSplitter."""
        # Update the status in the queue item based on the message content
        if 0 <= self.current_index < len(self.queue_items):
            queue_item = self.queue_items[self.current_index]
            
            # Check message content to set appropriate status
            if "Parsing document sections" in message:
                queue_item.status = "parsing"
            elif "Created archive" in message or "Saved" in message:
                # Document has been successfully saved
                queue_item.status = "completed"
            elif "Error" in message or "canceled" in message:
                queue_item.status = "error"
                queue_item.error = message
            elif "Processing" in message or "Creating" in message:
                queue_item.status = "processing"
        
        # Emit the status change with the message
        self.status_changed.emit(self.current_index, message)
    
    def _progress_callback(self, percent):
        """Progress callback for DocxSplitter."""
        self.progress_updated.emit(self.current_index, percent)
    
    def process_queue(self):
        """Process all queue items starting from current_index.
        Continuously checks for new items added to the queue."""
        try:
            self.is_running = True
            self.is_cancelled = False
            
            # Keep processing until explicitly cancelled
            while not self.is_cancelled:
                # First check cancellation again for responsive termination
                if self.is_cancelled:
                    print("Worker detected cancellation, stopping queue processing")
                    break
                    
                # Check if there are any queued items to process
                if self.current_index < len(self.queue_items):
                    # Process the next item
                    self._process_current_item()
                    self.current_index += 1
                else:
                    # No more items in the queue, check for new items every 500ms
                    QThread.msleep(100)  # Reduced sleep time for more responsive cancellation
                    # Check cancellation again after sleep
                    if self.is_cancelled:
                        break
                    
                    # If no new items after a few checks, exit loop
                    if all(item.status != "queued" for item in self.queue_items):
                        break
        except Exception as e:
            print(f"Error in process_queue: {e}")
        finally:
            # Always mark as not running when exiting
            self.is_running = False
            print("Queue processing thread exiting")
            # Emit completed signal in all cases
            self.all_completed.emit()
        
        self.is_running = False
        self.all_completed.emit()
    
    def _process_current_item(self):
        """Process the current queue item."""
        queue_item = self.queue_items[self.current_index]
        
        # First set status to parsing
        queue_item.status = "parsing"
        self.status_changed.emit(self.current_index, f"Parsing {queue_item.display_name}")
        
        try:
            # Create a DocxSplitter instance
            self.current_splitter = DocxSplitter(
                queue_item.input_path,
                queue_item.template_path,
                status_callback=self._status_callback,
                progress_callback=self._progress_callback
            )
            
            # Parse document sections
            self.current_splitter.parse_sections(queue_item.heading_level)
            
            # Check if operation was canceled
            if self.current_splitter.cancel_requested or self.is_cancelled:
                queue_item.status = "error"
                queue_item.error = "Operation canceled"
                self.item_error.emit(self.current_index, "Operation canceled")
                self.current_splitter = None
                return
            
            # Process the document
            result_path = self.current_splitter.process_document(
                queue_item.output_dir,
                target_level=queue_item.heading_level,
                create_zip=queue_item.create_zip,
                preserve_hierarchy=queue_item.preserve_hierarchy
            )
            
            # Check if operation was canceled
            if result_path is None or self.current_splitter.cancel_requested or self.is_cancelled:
                queue_item.status = "error"
                queue_item.error = "Operation canceled"
                self.item_error.emit(self.current_index, "Operation canceled")
                self.current_splitter = None
                return
            
            # Update queue item with result
            queue_item.result_path = result_path
            queue_item.status = "completed"
            queue_item.progress = 100
            self.item_completed.emit(self.current_index, result_path, "completed")
            
            # Clear current splitter reference
            self.current_splitter = None
            
        except Exception as e:
            # Handle errors
            error_message = str(e)
            queue_item.status = "error"
            queue_item.error = error_message
            self.item_error.emit(self.current_index, error_message)
            self.current_splitter = None
    
    def cancel(self):
        """Cancel current operations."""
        self.is_cancelled = True
        if self.current_splitter:
            self.current_splitter.cancel()

class HelpDialog(QDialog):
    """
    Comprehensive help dialog explaining application functionality.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Block Search Help")
        self.setMinimumSize(700, 600)
        
        # Main layout
        layout = QVBoxLayout(self)
        
        # Create a tab widget for organized help sections
        tab_widget = QTabWidget()
        layout.addWidget(tab_widget)
        
        # Add tabs for different help sections
        tab_widget.addTab(self._create_general_tab(), "General")
        tab_widget.addTab(self._create_search_tab(), "Searching your Blocks")
        tab_widget.addTab(self._create_document_tab(), "Sending to Doc")
        tab_widget.addTab(self._create_splitter_tab(), "Add Files to Index") 
        tab_widget.addTab(self._create_update_index_tab(), "Update Index")
        tab_widget.addTab(self._create_shortcuts_tab(), "Keyboard Shortcuts")
        
        # Add close button
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.accept)
        layout.addWidget(close_button)
    
    def _create_general_tab(self):
        """Create the general help tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        text = """
        <h2>Block Search Utility</h2>
        <p>Block Search helps you quickly send blocks to your speech document.</p>
        
        <h3>Getting Started:</h3>
        <ol>
            <li>Select the folder with your blocks from <b>Search Settings → Select Search Folder</b></li>
            <li>Type in the search box to find documents</li>
            <li>Click on a document to copy its contents</li>
        </ol>
        
        <h3>Search Settings:</h3>
        <p>The <b>Search Settings</b> menu provides several useful options:</p>
        <ul>
            <li><b>Select Search Folder:</b> Choose the folder containing your documents</li>
            <li><b>Show Current Folder:</b> Display information about the current search location</li>
            <li><b>Reindex:</b> Refresh the document index to pick up new or modified files</li>
            <li><b>Include Path in Search:</b> Include folder names when searching (Ctrl+Shift+P)</li>
            <li><b>Prefix Configuration:</b> Set up shortcuts for searching specific folders</li>
        </ul>
        """
        
        label = QLabel(text)
        label.setWordWrap(True)
        label.setTextFormat(Qt.TextFormat.RichText)
        
        layout.addWidget(label)
        layout.addStretch(1)
        
        return widget
    
    def _create_search_tab(self):
        """Create the search help tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        text = """
        <h2>Searching your Blocks</h2>
        
        <h3>Basic Search:</h3>
        <p>Type search terms in the search box to find matching documents. 
        Results update as you type.</p>
        
        <h3>Using Prefixes:</h3>
        <p>Prefixes let you limit searches to specific folders:</p>
        <ol>
            <li>Configure prefixes in <b>Search Settings → Prefix Configuration → Manage Prefixes</b></li>
            <li>Use format: <code>[prefix] [search terms]</code></li>
            <li>Example: <code>cb 2ac</code> searches for "2ac" only in folders assigned to "cb" prefix (say, condo bad!)</li>
        </ol>
        
        <h3>Sorting Results:</h3>
        <p>Use the <b>Sort</b> menu to order results by:
        <ul>
            <li>Name</li>
            <li>Date Modified</li>
            <li>Date Created</li>
            <li>Size</li>
        </ul>
        Toggle <b>Reverse Order</b> to switch between ascending and descending order.</p>
        """
        
        label = QLabel(text)
        label.setWordWrap(True)
        label.setTextFormat(Qt.TextFormat.RichText)
        
        layout.addWidget(label)
        layout.addStretch(1)
        
        return widget
    
    def _create_document_tab(self):
        """Create the document operations help tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        text = """
        <h2>Sending to Doc</h2>
        
        <h3>Document Content Transfer:</h3>
        <p>When you click on a document in search results, the content is handled based on your settings:</p>
        <ul>
            <li><b>Clipboard Mode:</b> Content is copied to clipboard (default when no target is set)</li>
            <li><b>Target Document Mode:</b> Content is appended to your selected closed document</li>
            <li><b>Active Document Mode:</b> Content is pasted into an open Word document</li>
        </ul>
        
        <h3>Setting a Target Document:</h3>
        <p>Use <b>Send to Closed Doc → Select Destination</b> to choose a document to receive content.
        Your block will be added to the end of this file when you click.</p>
        
        <h3>Using Open Word Documents:</h3>
        <p>The <b>Send to Open Doc</b> menu shows currently open Word documents:
        <ol>
            <li>Select a document from the menu to set it as the active target</li>
            <li>Use <b>Default Paste Mode</b> to control where content is inserted:
                <ul>
                    <li><b>Paste at Cursor:</b> Inserts at current cursor position</li>
                    <li><b>Paste at Document End:</b> Appends to the end of document</li>
                </ul>
            </li>
            <li>Press <b>Ctrl+Enter</b> to use the alternate paste mode</li>
        </ol>
        """
        
        label = QLabel(text)
        label.setWordWrap(True)
        label.setTextFormat(Qt.TextFormat.RichText)
        
        layout.addWidget(label)
        layout.addStretch(1)
        
        return widget
    
    def _create_splitter_tab(self):
        """Create the document splitter help tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        text = """
        <h2>Add Files to Index</h2>
        
        <h3>Overview:</h3>
        <p>The document splitter allows you to break large Word documents into smaller files based on heading levels.
        This allows you to extract blocks from large files and add them to your searchable index.</p>
        
        <h3>How to Access:</h3>
        <p>Navigate to <b>Index → Add Files to Index</b></p>
        
        <h3>Using the Queue System:</h3>
        <p>The utility supports adding multiple documents in sequence:</p>
        <ol>
            <li><b>Add Documents to Queue:</b> Configure settings for each document and add to the processing queue</li>
            <li><b>Manage Queue:</b> View, remove, or modify settings for queued documents</li>
            <li><b>Process Queue:</b> Start processing all documents in the queue</li>
            <li><b>Monitor Progress:</b> Track progress for each document in real-time</li>
        </ol>
        
        <h3>Document Configuration:</h3>
        <ol>
            <li><b>Select Input Document:</b> Choose the Word document you want to split</li>
            <li><b>Choose Template Document (Recommended):</b> Select a document to use as a template for output files. This should be a blank Word document created using your version of Verbatim.</li> 
                <ul>
                    <li>If no template is selected, a minimal default template will be created</li>
                </ul>
            </li>
            <li><b>Select Heading Level:</b> Choose which heading level to split at (Heading 1-4)
                <ul>
                    <li>The document will be divided at each heading of the selected level</li>
                    <li>Each heading and its content will become a separate document</li>
                </ul>
            </li>
            <li><b>Choose Output Options:</b>
                <ul>
                    <li><b>Create ZIP Archive:</b> Package all split documents into a single ZIP file</li>
                    <li><b>Individual Files:</b> Save each section as a separate document</li>
                    <li><b>Preserve Hierarchy:</b> Maintain the original document's structure in folders</li>
                </ul>
            </li>
            <li><b>Select Output Location:</b> Choose where to save the output files</li>
            <li><b>Add to Queue:</b> Add the configured document to the processing queue</li>
        </ol>
        
        <h3>Queue Management:</h3>
        <ul>
            <li><b>View Status:</b> Monitor progress for each document in the queue</li>
            <li><b>Change Destination:</b> Modify the output location for queued documents</li>
            <li><b>Remove Items:</b> Remove documents from the queue before processing</li>
            <li><b>Cancel Processing:</b> Stop the current operation if needed</li>
        </ul>
        
        <h3>Tips:</h3>
        <ul>
            <li>Results will be best for files that use Verbatim styles</li>
            <li>Heading 1 will target Pockets, Heading 2 Hats, Heading 3 Blocks, and Heading 4 Tags</li>
            <li>Use the ZIP option for easier management if you need to share the index</li>
            <li>For large documents, processing may take some time - the queue system lets you set up multiple jobs</li>
        </ul>
        """
        
        label = QLabel(text)
        label.setWordWrap(True)
        label.setTextFormat(Qt.TextFormat.RichText)
        
        layout.addWidget(label)
        layout.addStretch(1)
        
        return widget

    def _create_update_index_tab(self):
        """Create the update index help tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        text = """
        <h2>Update Index</h2>
        
        <h3>Overview:</h3>
        <p>The Update Index feature allows you to refresh existing index folders with new content or modifications
        without having to recreate the entire index from scratch.</p>
        
        <h3>How to Access:</h3>
        <p>Navigate to <b>Index → Update Index</b></p>
        
        <h3>Update Tabs:</h3>
        <p>The Update Index dialog provides two tabs for different workflows:</p>
        
        <h4>1. Update All</h4>
        <ul>
            <li><b>Purpose:</b> Automatically detect and queue all source documents at once</li>
            <li><b>When to Use:</b> When you have multiple source documents that need updating</li>
            <li><b>Process:</b> 
                <ul>
                    <li>Select an index folder containing multiple source document subfolders</li>
                    <li>The system automatically discovers all source documents from metadata files</li>
                    <li>All documents are queued for processing with their original settings</li>
                </ul>
            </li>
            <li><b>Convenience:</b> No need to manually select each document</li>
        </ul>
        
        <h4>2. Update by Document</h4>
        <ul>
            <li><b>Purpose:</b> Manually update individual documents within an index</li>
            <li><b>When to Use:</b> When you want to update specific documents one at a time</li>
            <li><b>Process:</b>
                <ul>
                    <li>Select a folder containing a single document's index files</li>
                    <li>Settings are read from the existing metadata file</li>
                    <li>Process the single document with chosen update mode</li>
                </ul>
            </li>
        </ul>
        
        <h3>Update Modes (Available in Both Tabs):</h3>
        <ul>
            <li><b>Add New Only:</b> Only add headings that don't already exist (incremental update)</li>
            <li><b>Rebuild All:</b> Delete and recreate all content ⚠️ <em>This completely overwrites existing content</em></li>
            <li><b>Remove deleted headings:</b> Clean up headings no longer in source (checked by default)</li>
        </ul>
        
        <h3>Tips:</h3>
        <ul>
            <li>Use "Add New Only" mode for incremental changes to save time</li>
            <li>Use "Rebuild All" mode when you want to ensure complete consistency (overwrites existing content)</li>
            <li>Use "Update All" tab for batch processing multiple documents</li>
            <li>Use "Update by Document" tab for focused updates on specific documents</li>
            <li>The system automatically uses the heading level and hierarchy settings from when the index was created</li>
            <li>If metadata files are missing, recreate the index using "Add Files to Index"</li>
        </ul>
        """
        
        label = QLabel(text)
        label.setWordWrap(True)
        label.setTextFormat(Qt.TextFormat.RichText)
        
        layout.addWidget(label)
        layout.addStretch(1)
        
        return widget

    def _create_shortcuts_tab(self):
        """Create the keyboard shortcuts help tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        text = """
        <h2>Keyboard Shortcuts</h2>
        
        <h3>Application Shortcuts:</h3>
        <table border="0" cellspacing="8">
            <tr>
                <td><b>Ctrl+Space</b></td>
                <td>Show/activate application (configurable)</td>
            </tr>
            <tr>
                <td><b>Escape</b></td>
                <td>Hide application window</td>
            </tr>
            <tr>
                <td><b>F5</b></td>
                <td>Refresh open documents list</td>
            </tr>
            <tr>
                <td><b>Ctrl+T</b></td>
                <td>Select (closed) target document</td>
            </tr>
            <tr>
                <td><b>Ctrl+Shift+T</b></td>
                <td>Clear (closed) target document</td>
            </tr>
            <tr>
                <td><b>Ctrl+P</b></td>
                <td>Toggle between paste modes (cursor/end)</td>
            </tr>
            <tr>
                <td><b>Ctrl+Shift+P</b></td>
                <td>Toggle including path names in search</td>
            </tr>
            <tr>
                <td><b>Alt+F4, Ctrl+Q</b></td>
                <td>Quit application</td>
            </tr>
        </table>
        
        <h3>Search Result Navigation:</h3>
        <table border="0" cellspacing="8">
            <tr>
                <td><b>Up/Down</b></td>
                <td>Navigate through search results</td>
            </tr>
            <tr>
                <td><b>Enter</b></td>
                <td>Select document (use default paste mode)</td>
            </tr>
            <tr>
                <td><b>Ctrl+Enter</b></td>
                <td>Select document (use alternate paste mode)</td>
            </tr>
            <tr>
                <td><b>Shift+Enter</b></td>
                <td>Show document preview</td>
            </tr>
            <tr>
                <td><b>Left Arrow</b></td>
                <td>Show document in its original context</td>
            </tr>
            <tr>
                <td><b>Right Arrow</b></td>
                <td>Return from context view to search results</td>
            </tr>
            <tr>
                <td><b>F1</b></td>
                <td>Show this help dialog</td>
            </tr>
        </table>
        """
        
        label = QLabel(text)
        label.setWordWrap(True)
        label.setTextFormat(Qt.TextFormat.RichText)
        
        layout.addWidget(label)
        layout.addStretch(1)
        
        return widget

class DocumentPreviewDialog(QDialog):
    """
    Document preview dialog with simplified HTML-based rendering.
    
    This dialog provides a simple preview of Word documents by
    extracting content and formatting using python-docx and
    displaying it as HTML in a QTextEdit widget.
    """
    
    def __init__(self, document_path, parent=None):
        super().__init__(parent)
        self.document_path = document_path
        self.temp_files = []  # Track temporary files for cleanup
        
        # Define highlight color mapping
        self.highlight_colors = {
            "Yellow": "#FFFF00",
            "Light Blue": "#ADD8E6",
            "Green": "#90EE90"
        }
        self.current_highlight_color = self.highlight_colors["Yellow"]  # Default
        
        # Setup basic UI
        self.setWindowTitle(f"Preview: {Path(document_path).name}")
        self.resize(900, 700)
        self.setup_ui()
        
        # Load document with progress indication
        self.progress_bar.show()
        QTimer.singleShot(100, self.load_document)
    
    def setup_ui(self):
        """Set up the user interface with flexible layout."""
        layout = QVBoxLayout(self)
        
        # Document info header
        info_layout = QHBoxLayout()
        self.doc_info_label = QLabel(f"Loading document...")
        info_layout.addWidget(self.doc_info_label)
        
        # Highlight color selector
        highlight_label = QLabel("Highlight Color:")
        info_layout.addWidget(highlight_label)
        
        self.highlight_color_combo = QComboBox()
        self.highlight_color_combo.addItems(["Yellow", "Light Blue", "Green"])
        self.highlight_color_combo.setCurrentIndex(0)  # Default to yellow
        self.highlight_color_combo.currentIndexChanged.connect(self.change_highlight_color)
        info_layout.addWidget(self.highlight_color_combo)
        
        layout.addLayout(info_layout)
        
        # Progress bar (initially hidden)
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 0)  # Indeterminate
        self.progress_bar.hide()
        layout.addWidget(self.progress_bar)
        
        # Text viewer
        self.text_viewer = QTextEdit()
        self.text_viewer.setReadOnly(True)
        self.text_viewer.setWordWrapMode(QTextOption.WrapMode.WordWrap)
        layout.addWidget(self.text_viewer)
        
        # Button row
        btn_layout = QHBoxLayout()
        
        # Copy buttons
        self.copy_btn = QPushButton("Copy to Clipboard")
        self.copy_btn.clicked.connect(self.copy_to_clipboard)
        btn_layout.addWidget(self.copy_btn)
        
        # Selection copy buttons  
        self.copy_selection_btn = QPushButton("Copy Selection")
        self.copy_selection_btn.clicked.connect(self.copy_selection)
        btn_layout.addWidget(self.copy_selection_btn)
        
        btn_layout.addStretch()
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        btn_layout.addWidget(close_btn)
        
        layout.addLayout(btn_layout)
    
    def load_document(self):
        """Load document with HTML-based renderer."""
        try:
            self.load_with_fallback()
            self.progress_bar.hide()
        except Exception as e:
            self.doc_info_label.setText(f"Error loading document: {str(e)}")
            print(f"Document preview error: {e}")
            self.progress_bar.hide()
    
    def change_highlight_color(self, index):
        """Update the highlight color and refresh the view."""
        color_name = self.highlight_color_combo.currentText()
        self.current_highlight_color = self.highlight_colors[color_name]
        
        # Refresh the view
        self.load_with_fallback()
    
    def load_with_fallback(self):
        """Load document with improved python-docx based renderer."""
        self.doc_info_label.setText("Loading document...")
        
        try:
            import docx
            document = docx.Document(self.document_path)
            
            # Create HTML content from document with improved formatting
            html_content = ["<html><body style='font-family: Arial, sans-serif; margin: 20px;'>"]
            
            # Process paragraphs with style information
            for para in document.paragraphs:
                # Skip empty paragraphs but preserve as space
                if not para.text.strip():
                    html_content.append("<p>&nbsp;</p>")
                    continue
                    
                # Extract paragraph style information
                para_styles = self.extract_paragraph_style(para)
                style_attr = f" style=\"{para_styles}\"" if para_styles else ""
                
                # Handle different paragraph types based on style
                if para.style and para.style.name.startswith('Heading '):
                    try:
                        level = int(para.style.name.split()[-1])
                        if 1 <= level <= 6:  # Valid HTML heading levels
                            html_content.append(f"<h{level}{style_attr}>{self.format_runs_as_html(para.runs)}</h{level}>")
                        else:
                            # Fallback for unusual heading levels
                            html_content.append(f"<p{style_attr}><strong>{self.format_runs_as_html(para.runs)}</strong></p>")
                    except (ValueError, IndexError):
                        # Fallback if heading level can't be determined
                        html_content.append(f"<p{style_attr}><strong>{self.format_runs_as_html(para.runs)}</strong></p>")
                else:
                    html_content.append(f"<p{style_attr}>{self.format_runs_as_html(para.runs)}</p>")
            
            html_content.append("</body></html>")
            
            # Set the HTML content to the text viewer
            self.text_viewer.setHtml("".join(html_content))
            self.doc_info_label.setText(f"{Path(self.document_path).name}")
            
        except Exception as e:
            print(f"Basic fallback renderer failed: {e}")
            self.text_viewer.setPlainText(f"Error loading document: {e}\n\nDocument path: {self.document_path}")
            self.doc_info_label.setText(f"Error: {str(e)}")
    
    def extract_paragraph_style(self, para):
        """Extract paragraph styling information."""
        styles = []
        
        # Handle alignment
        if hasattr(para, 'paragraph_format') and para.paragraph_format:
            # Alignment
            if hasattr(para.paragraph_format, 'alignment'):
                alignment = para.paragraph_format.alignment
                if alignment == 1:  # WD_ALIGN_LEFT
                    styles.append("text-align: left;")
                elif alignment == 2:  # WD_ALIGN_CENTER
                    styles.append("text-align: center;")
                elif alignment == 3:  # WD_ALIGN_RIGHT
                    styles.append("text-align: right;")
                elif alignment == 4:  # WD_ALIGN_JUSTIFY
                    styles.append("text-align: justify;")
            
            # Indentation
            if hasattr(para.paragraph_format, 'left_indent') and para.paragraph_format.left_indent:
                try:
                    indent_pt = para.paragraph_format.left_indent.pt
                    styles.append(f"padding-left: {indent_pt}pt;")
                except:
                    pass
            
            # Line spacing
            if hasattr(para.paragraph_format, 'line_spacing'):
                try:
                    if para.paragraph_format.line_spacing:
                        styles.append(f"line-height: {para.paragraph_format.line_spacing:.1f};")
                except:
                    pass
            
            # Spacing before/after
            if hasattr(para.paragraph_format, 'space_before') and para.paragraph_format.space_before:
                try:
                    space_pt = para.paragraph_format.space_before.pt
                    styles.append(f"margin-top: {space_pt}pt;")
                except:
                    pass
                    
            if hasattr(para.paragraph_format, 'space_after') and para.paragraph_format.space_after:
                try:
                    space_pt = para.paragraph_format.space_after.pt
                    styles.append(f"margin-bottom: {space_pt}pt;")
                except:
                    pass
        
        # Check for specific style types from the style name
        if para.style:
            style_name = para.style.name.lower()
            
            # Common style identification patterns
            if 'quote' in style_name or 'block' in style_name:
                styles.append("border-left: 3px solid #ccc; padding-left: 10px; font-style: italic;")
            elif 'list' in style_name:
                styles.append("margin-left: 20px;")
        
        return " ".join(styles)
    
    def format_runs_as_html(self, runs):
        """Convert paragraph runs to HTML with enhanced formatting."""
        result = []
        for run in runs:
            # Handle empty runs
            if not run.text:
                continue
                
            # Escape HTML special characters
            text = run.text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
            
            # Build style attributes
            styles = []
            
            # Basic formatting
            if run.bold:
                styles.append("font-weight: bold;")
            if run.italic:
                styles.append("font-style: italic;")
            if run.underline:
                styles.append("text-decoration: underline;")
            
            # Handle font properties
            if hasattr(run, 'font'):
                # Font name/family
                if run.font.name:
                    styles.append(f"font-family: '{run.font.name}', Arial, sans-serif;")
                
                # Font size
                if run.font.size:
                    try:
                        # Convert half-points to points if necessary
                        pt_size = run.font.size.pt if hasattr(run.font.size, 'pt') else run.font.size / 2
                        styles.append(f"font-size: {pt_size}pt;")
                    except:
                        pass
                
                # Font color
                if hasattr(run.font, 'color') and run.font.color and run.font.color.rgb:
                    color = run.font.color.rgb
                    # Make sure we have a proper color format
                    if isinstance(color, str):
                        color = color.replace('0x', '')
                        if len(color) == 6:
                            styles.append(f"color: #{color};")
                
                # Highlight - use our configurable highlight color
                if hasattr(run.font, 'highlight_color') and run.font.highlight_color:
                    styles.append(f"background-color: {self.current_highlight_color};")
                
                # All caps
                if hasattr(run.font, 'all_caps') and run.font.all_caps:
                    styles.append("text-transform: uppercase;")
                
                # Small caps
                if hasattr(run.font, 'small_caps') and run.font.small_caps:
                    styles.append("font-variant: small-caps;")
            
                # Handle special cases based on style names
                if hasattr(run, 'style') and run.style and run.style.name:
                    style_name = run.style.name.lower()
                    
                    # Debug the style name - can be removed later
                    print(f"Style name: {style_name}")
                    
                    # Look for cite or bold anywhere in the style name
                    if 'cite' in style_name:
                        styles.append("font-weight: bold;")
                    elif 'bold' in style_name:
                        styles.append("font-weight: bold;")
                    elif 'underline' in style_name:
                        styles.append("text-decoration: underline;")
                    elif 'emphasis' in style_name:
                        styles.append("font-weight: bold; text-decoration: underline;")
            
            # Create span with styles or just text if no styles
            if styles:
                result.append(f"<span style=\"{' '.join(styles)}\">{text}</span>")
            else:
                result.append(text)
        
        return "".join(result)
    
    def copy_to_clipboard(self):
        """Copy document content to clipboard."""
        try:
            # Copy from text viewer
            self.text_viewer.selectAll()
            self.text_viewer.copy()
            self.text_viewer.moveCursor(self.text_viewer.textCursor().Start)
            self.doc_info_label.setText("Copied document text to clipboard")
        except Exception as e:
            self.doc_info_label.setText(f"Error copying to clipboard: {str(e)}")
    
    def copy_selection(self):
        """Copy selected content to clipboard."""
        try:
            # Get text viewer selection
            cursor = self.text_viewer.textCursor()
            if cursor.hasSelection():
                self.text_viewer.copy()
                self.doc_info_label.setText("Copied selection to clipboard")
            else:
                self.doc_info_label.setText("No text selected")
        except Exception as e:
            self.doc_info_label.setText(f"Error copying selection: {str(e)}")
    
    def closeEvent(self, event):
        """Clean up resources when dialog is closed."""
        # Clean up temporary files
        for temp_file in self.temp_files:
            try:
                if os.path.exists(temp_file):
                    os.unlink(temp_file)
            except Exception as e:
                print(f"Error removing temp file {temp_file}: {e}")
        
        super().closeEvent(event)

class StyleProcessor:
    """
    Processes and manages document styles, handling paragraph styles.
    """
    
    def __init__(self, doc: Document):
        self.doc = doc
        self.heading_levels: Dict[str, int] = {}
        self._process_styles()
    
    def _process_styles(self) -> None:
        for style in self.doc.styles:
            if style.type != WD_STYLE_TYPE.PARAGRAPH:
                continue
                
            # Handle built-in heading styles
            if style.name.startswith('Heading '):
                try:
                    level = int(style.name.split()[-1])
                    self.heading_levels[style.name] = level
                except (ValueError, IndexError):
                    continue
            
            # Handle custom styles based on headings
            elif hasattr(style, 'base_style') and style.base_style:
                base_name = style.base_style.name
                if base_name.startswith('Heading '):
                    try:
                        level = int(base_name.split()[-1])
                        self.heading_levels[style.name] = level
                    except (ValueError, IndexError):
                        continue
    
    def get_heading_level(self, paragraph: Paragraph) -> Optional[int]:
        if not paragraph.style or not paragraph.style.name:
            return None
        return self.heading_levels.get(paragraph.style.name)

class FilenameManager:
    """Handles creation and management of safe filenames."""
    
    @staticmethod
    def sanitize_filename(title: str, max_length: int = 240) -> str:
        # Remove invalid chars
        safe = re.sub(r'[<>:"/\\|?*]', '', title)
        # Replace whitespace with underscore
        safe = re.sub(r'\s+', '_', safe)
        # Remove duplicate dots
        safe = re.sub(r'\.+', '.', safe)
        # Truncate if needed
        safe = safe[:max_length]
        # Remove leading/trailing dots and underscores
        return safe.strip('._')
    
    def ensure_unique(self, filename: str, used_names: Set[str]) -> str:
        base = filename
        counter = 1
        
        while filename in used_names:
            name_parts = base.rsplit('.', 1)
            if len(name_parts) > 1:
                filename = f"{name_parts[0]}_{counter}.{name_parts[1]}"
            else:
                filename = f"{base}_{counter}"
            counter += 1
            
        used_names.add(filename)
        return filename

class DocxSplitter:
    """
    Main class for splitting Word documents by heading level.
    Enhanced to support various output options and cancellation.
    """
    
    def __init__(self, input_path: Path, template_path: Path, status_callback=None, progress_callback=None):
        """
        Initialize the splitter with progress reporting.
        
        Args:
            input_path: Path to document to split
            template_path: Path to template document
            status_callback: Optional callback for status updates
            progress_callback: Optional callback for progress updates (0-100)
        """
        self.input_path = input_path
        self.template_path = template_path
        self.status_callback = status_callback or (lambda msg: None)
        self.progress_callback = progress_callback or (lambda percent: None)
        
        # Verify template exists
        if not template_path.exists():
            raise ValueError(f"Template document not found: {template_path}")
        
        self.doc = docx.Document(input_path)
        self.style_processor = StyleProcessor(self.doc)
        self.filename_manager = FilenameManager()
        self.sections: List[Section] = []
        
        # Add a cancel flag
        self.cancel_requested = False
    
    def cancel(self):
        """Request cancellation of the current operation."""
        print("DocxSplitter.cancel() method called!")  # Debug
        self.cancel_requested = True
        print(f"cancel_requested flag set to {self.cancel_requested}")  # Debug
        self.status_callback("Cancellation requested")
    
    def _clean_document(self, doc: Document, target_level: int) -> Document:
        """
        Clean document by removing higher-level headings and empty headers.
        Preserves the target heading level for splitting.
        
        Args:
            doc: Document to clean
            target_level: The heading level we're splitting on (to preserve)
        """
        paragraphs_to_remove = []
        
        for idx, para in enumerate(doc.paragraphs):
            # Check for cancellation during cleaning
            if idx % 100 == 0 and self.cancel_requested:
                self.status_callback("Operation canceled during document cleaning")
                return doc
                
            level = self.style_processor.get_heading_level(para)
            
            # Check if this is a heading
            if level is not None:
                # Remove if:
                # 1. It's a heading that's higher in hierarchy than our target level
                #    BUT is not our target level itself
                # 2. It's an empty heading (any level, including target level)
                if (level < target_level and level != target_level) or not para.text.strip():
                    paragraphs_to_remove.append(idx)
                    # Mark the next paragraph for removal if it's empty
                    if idx + 1 < len(doc.paragraphs) and not doc.paragraphs[idx + 1].text.strip():
                        paragraphs_to_remove.append(idx + 1)
        
        # Remove paragraphs in reverse order to maintain correct indices
        for idx in sorted(paragraphs_to_remove, reverse=True):
            if idx < len(doc.paragraphs):  # Safety check
                p = doc.paragraphs[idx]._element
                p.getparent().remove(p)
        
        return doc
    
    def parse_sections(self, target_level: int = 3) -> None:
        """Parse document into sections with improved parent detection."""
        self.status_callback(f"Parsing document sections at heading level {target_level}...")
        
        # First collect ALL headings at ALL levels with their positions
        headings_by_level = {level: [] for level in range(1, target_level + 1)}
        all_sections = []
        used_titles = set()
        
        # First pass: Find all headings and create section objects
        print(f"Scanning document for headings up to level {target_level}...")
        for idx, para in enumerate(self.doc.paragraphs):
            level = self.style_processor.get_heading_level(para)
            
            if level is not None and 1 <= level <= target_level and para.text.strip():
                safe_title = self.filename_manager.sanitize_filename(para.text)
                unique_title = self.filename_manager.ensure_unique(safe_title, used_titles)
                
                # Create section object
                section = Section(
                    title=para.text,
                    safe_title=unique_title,
                    level=level,
                    content=[],
                    start_index=idx,
                    end_index=None  # Will set later
                )
                
                # Add to our collections
                headings_by_level[level].append(section)
                all_sections.append(section)
                print(f"Found heading level {level}: '{para.text}' at index {idx}")
        
        # Sort all sections by start index to ensure they're in document order
        all_sections.sort(key=lambda s: s.start_index)
        
        # Set end indices based on the next section of any level
        for i in range(len(all_sections) - 1):
            all_sections[i].end_index = all_sections[i + 1].start_index - 1
        
        # Set end index for the last section
        if all_sections:
            all_sections[-1].end_index = len(self.doc.paragraphs) - 1
        
        # Second pass: Fill in content - optimized approach
        total_sections = len(all_sections)
        total_paragraphs = len(self.doc.paragraphs)
        self.status_callback(f"Organizing content for {total_sections} sections ({total_paragraphs} paragraphs total)...")
        print(f"Organizing content for {total_sections} sections ({total_paragraphs} paragraphs total)...")
        
        # Only show detailed progress for documents with many sections
        show_detailed_progress = total_sections > 50 or total_paragraphs > 5000
        
        # Cache doc.paragraphs as list - this prevents repeated COM object access which is slow
        # This is a critical optimization for large documents with many paragraphs
        paragraphs_list = list(self.doc.paragraphs)
        paragraphs_len = len(paragraphs_list)
        
        # Process sections in batches with fewer progress updates
        section_batch_size = max(1, total_sections // 20)  # Report progress at 5% intervals
        paragraphs_processed = 0
        
        # Process sections with minimal overhead
        for section_idx, section in enumerate(all_sections):
            # Report section progress only at intervals - reduces overhead from UI updates
            if show_detailed_progress and section_idx % section_batch_size == 0:
                batch_progress = min(100, int((section_idx / total_sections) * 100))
                self.status_callback(f"Processing section {section_idx+1}/{total_sections} content...")
                self.progress_callback(batch_progress)
            
            # Check for cancellation periodically
            if section_idx % 50 == 0 and self.cancel_requested:
                self.status_callback("Cancellation requested during content processing")
                break
                
            # Fast batch assignment of content instead of appending one by one
            # This eliminates the inner loop and improves performance dramatically
            start_idx = section.start_index
            end_idx = min(section.end_index + 1, paragraphs_len)
            section.content = paragraphs_list[start_idx:end_idx]
            
            # Update count for total processed paragraphs
            paragraphs_processed += end_idx - start_idx
        
        self.status_callback(f"Content organization complete - processed {paragraphs_processed} paragraphs")
        print(f"Content organization complete - processed {paragraphs_processed} paragraphs")
        
        # Third pass: Establish parent-child relationships
        self.status_callback(f"Building parent-child relationships for {len(all_sections)} sections...")
        print("Building parent-child relationships...")
        
        # Track progress for large documents
        total_sections = len(all_sections)
        # Only report progress for documents with many sections to avoid UI clutter
        show_detailed_progress = total_sections > 100
        
        try:
            for i, section in enumerate(all_sections):
                # Report progress periodically for large documents
                if show_detailed_progress and i % 100 == 0:
                    percent_complete = int(i / total_sections * 100)
                    self.status_callback(f"Building relationships: {i}/{total_sections} sections processed ({percent_complete}%)")
                    # Do not update progress bar for relationship building
                    # self.progress_callback(percent_complete)
                    
                if section.level > 1:  # Skip level 1 as they have no parents
                    # Find closest preceding section with a lower level - using the original algorithm
                    for idx in range(all_sections.index(section) - 1, -1, -1):
                        potential_parent = all_sections[idx]
                        if potential_parent.level < section.level:
                            section.parent = potential_parent
                            potential_parent.children.append(section)
                            # Only print detailed info for smaller documents to reduce output
                            if not show_detailed_progress:
                                print(f"Set parent for '{section.title}' (level {section.level}) -> '{potential_parent.title}' (level {potential_parent.level})")
                            break
        except Exception as e:
            error_msg = f"Error building parent-child relationships: {str(e)}"
            print(error_msg)
            self.status_callback(error_msg)
        
        # Fourth pass: Collect just the target level sections
        self.sections = [s for s in all_sections if s.level == target_level]
        self.sections = [s for s in self.sections if any(p.text.strip() for p in s.content)]
        
        # Debug information
        sections_with_parent = sum(1 for s in self.sections if s.parent is not None)
        print(f"Sections with parent: {sections_with_parent}/{len(self.sections)}")
        
        # Print paths for a few sections to verify
        for i, section in enumerate(self.sections[:5]):
            if i >= len(self.sections):
                break
            path = section.get_path_components()
            if path:
                print(f"Section {i+1} path: {'/'.join(path)}/{section.safe_title}")
            else:
                print(f"Section {i+1} has no parent path: {section.safe_title}")
        
        self.status_callback(f"Found {len(self.sections)} sections at level {target_level}")
    
    def process_document(self, output_dir: Path, target_level: int = 3, 
                        create_zip: bool = True, preserve_hierarchy: bool = False) -> Path:
        """
        Process the document and output files according to specified options.
        
        Args:
            output_dir: Output directory for files
            target_level: Heading level to split on (default: 3)
            create_zip: Whether to create a zip archive or individual files
            preserve_hierarchy: Whether to preserve document hierarchy in folder structure
            
        Returns:
            Path: Path to created output (zip file or directory) or None if canceled
        """
        # Make sure we have parsed sections
        if not self.sections:
            self.parse_sections(target_level)
            
        # Check if parsing was canceled
        if self.cancel_requested or not self.sections:
            return None
            
        # Explicitly indicate we're now processing (not parsing)
        if create_zip:
            self.status_callback(f"Processing: Creating ZIP archive with {len(self.sections)} sections...")
        else:
            self.status_callback(f"Processing: Creating {len(self.sections)} individual documents...")
        
        # Create output directory if it doesn't exist
        output_dir.mkdir(parents=True, exist_ok=True)
        
        if create_zip:
            return self._create_zip_archive(output_dir, preserve_hierarchy)
        else:
            return self._save_individual_files(output_dir, preserve_hierarchy)
    
    def process_document_update(self, output_dir: Path, target_level: int = 3,
                               preserve_hierarchy: bool = False, skip_existing: bool = True,
                               progress_callback=None) -> Path:
        """
        Process the document for update operations with skip-existing functionality.
        
        Args:
            output_dir: Output directory for files
            target_level: Heading level to split on (default: 3)
            preserve_hierarchy: Whether to preserve document hierarchy in folder structure
            skip_existing: Whether to skip files that already exist
            progress_callback: Optional callback for detailed progress (current, total, action)
            
        Returns:
            Path: Path to output directory or None if canceled
        """
        # Make sure we have parsed sections
        if not self.sections:
            self.parse_sections(target_level)
            
        # Check if parsing was canceled
        if self.cancel_requested or not self.sections:
            return None
            
        self.status_callback(f"Processing: Updating {len(self.sections)} sections...")
        
        # Create output directory if it doesn't exist
        output_dir.mkdir(parents=True, exist_ok=True)
        
        return self._save_individual_files_update(output_dir, preserve_hierarchy, skip_existing, progress_callback)
    
    def _save_individual_files_update(self, output_dir: Path, preserve_hierarchy: bool = False,
                                    skip_existing: bool = True, progress_callback=None) -> Path:
        """Save individual files with update support (skip existing files)."""
        import concurrent.futures
        import json
        from threading import Lock
        
        total_sections = len(self.sections)
        files_created = 0
        files_skipped = 0
        progress_lock = Lock()
        
        # Initial status update
        self.status_callback(f"Updating documents: checking {total_sections} sections...")
        
        # Function to process a single section
        def process_section(task):
            idx, section = task
            
            if self.cancel_requested:
                return None
                
            result = {
                "success": False,
                "section_title": section.safe_title,
                "error": None,
                "output_file": None,
                "action": "skipped"  # "created" or "skipped"
            }
            
            try:
                # The filename is simply the safe_title
                filename = section.safe_title
                
                # Determine output path
                if preserve_hierarchy and section.parent is not None:
                    folder_components = section.get_path_components()
                    section_dir = output_dir
                    
                    for component in folder_components:
                        section_dir = section_dir / component
                        with progress_lock:
                            section_dir.mkdir(exist_ok=True, parents=True)
                    
                    output_file = section_dir / f"{filename}.docx"
                else:
                    output_file = output_dir / f"{filename}.docx"
                
                # Check if file exists
                if skip_existing and output_file.exists():
                    result["success"] = True
                    result["action"] = "skipped"
                    result["output_file"] = output_file
                    print(f"SKIPPED: {section.safe_title} (file already exists)")
                    return result
                
                # File doesn't exist or we're not skipping - create it
                print(f"CREATING: {section.safe_title}")
                doc = self._create_section_document(section)
                
                # Add metadata
                metadata = self._add_document_metadata(doc, section, self.sections)
                
                # Save document
                doc.save(str(output_file))
                
                # Save metadata file if we have metadata
                if metadata:
                    meta_file = output_file.with_suffix(output_file.suffix + '.meta.json')
                    with open(meta_file, 'w', encoding='utf-8') as f:
                        json.dump(metadata, f, indent=2)
                
                result["success"] = True
                result["action"] = "created"
                result["output_file"] = output_file
                print(f"CREATED: {section.safe_title} -> {output_file}")
                
            except Exception as e:
                result["error"] = str(e)
                
            return result
        
        # Process sections with progress reporting
        completed = 0
        errors = []
        
        # Create list of tasks
        tasks = [(i, section) for i, section in enumerate(self.sections)]
        
        # Process sections sequentially for better progress reporting
        for task in tasks:
            if self.cancel_requested:
                break
                
            result = process_section(task)
            
            if result:
                if result["success"]:
                    if result["action"] == "created":
                        files_created += 1
                        action_msg = f"Created: {result['section_title']}"
                    else:
                        files_skipped += 1
                        action_msg = f"Skipped: {result['section_title']} (already exists)"
                        
                    self.status_callback(action_msg)
                else:
                    errors.append(f"Error processing {result['section_title']}: {result['error']}")
            
            completed += 1
            
            # Update progress
            percent = int((completed / total_sections) * 100)
            self.progress_callback(percent)
            
            # Call detailed progress callback if provided
            if progress_callback:
                progress_callback(completed, total_sections, result.get("action", "unknown"))
        
        # Final status update
        if self.cancel_requested:
            self.status_callback("Update operation canceled")
            return None
        
        # Report any errors
        if errors:
            self.status_callback(f"Update completed with {len(errors)} errors")
            for error in errors[:5]:  # Show first 5 errors
                print(error)
            if len(errors) > 5:
                print(f"... and {len(errors) - 5} more errors")
        else:
            self.status_callback(
                f"Update completed: {files_created} created, {files_skipped} skipped"
            )
        
        return output_dir
    
    def _add_document_metadata(self, doc: Document, section: Section, all_sections: List[Section]) -> None:
        """
        Add hierarchy metadata to document custom properties.
        
        Args:
            doc: Document to add metadata to
            section: Current section being processed
            all_sections: All sections in the document for sibling relationships
        """
        try:
            # Get current timestamp for indexing time
            current_time = datetime.now().timestamp()
            
            # Create metadata dictionary
            metadata = {
                "original_doc_path": str(self.input_path),
                "position_in_original": section.start_index,
                "section_level": section.level,
                "section_title": section.title,
                "is_index_generated": True,
                "source_file": str(self.input_path),
                "source_file_mtime": self.input_path.stat().st_mtime,
                "indexed_timestamp": current_time
            }
            
            # Add parent info if available
            if section.parent:
                metadata["parent_doc_name"] = section.parent.safe_title
            
            # Find all sections with the same parent (or no parent) and at the same level
            siblings = []
            for s in all_sections:
                if s.level == section.level:
                    if (section.parent is None and s.parent is None) or \
                       (section.parent is not None and s.parent is not None and 
                        section.parent.safe_title == s.parent.safe_title):
                        siblings.append(s)
            
            # Sort siblings by position in document
            siblings.sort(key=lambda s: s.start_index)
            
            # Store sibling names (excluding self)
            metadata["sibling_docs"] = [s.safe_title for s in siblings if s.safe_title != section.safe_title]
            
            # Still try to add some core properties for backward compatibility,
            # but keep them short to avoid exceeding limits
            core_props = doc.core_properties
            try:
                # Try to add minimal metadata to the document properties
                core_props.identifier = "Original: " + Path(self.input_path).name
                core_props.category = f"position:{section.start_index}"
                if section.parent:
                    core_props.subject = f"parent:{section.parent.safe_title[:50]}" if section.parent.safe_title else ""
            except Exception as e:
                print(f"Warning: Could not add core properties: {e}")
                
            # Return the metadata - it will be saved to a separate file by the caller
            return metadata
                
        except Exception as e:
            print(f"Error creating metadata: {e}")
            return None
    
    def _create_section_document(self, section: Section) -> Document:
        """
        Create new document from section content using template.
        
        Args:
            section: Section to convert to document
            
        Returns:
            Document: New document containing section content with preserved formatting
        """
        # Create new document from template
        new_doc = docx.Document(self.template_path)
        
        # Remove any existing paragraphs from the template
        for p in new_doc.paragraphs[::-1]:  # Iterate in reverse for stable removal
            p._element.getparent().remove(p._element)
        
        # Add the heading as document title (will be first content)
        heading = new_doc.add_heading(section.title, level=section.level)
        
        # Copy content while preserving formatting
        for para in section.content:
            # Skip the heading since we've already added it
            if para.text == section.title:
                continue
                
            # Skip empty paragraphs
            if not para.text.strip():
                continue
                
            new_para = new_doc.add_paragraph()
            
            # Copy runs with careful attribute handling
            for run in para.runs:
                new_run = new_para.add_run(run.text)
                
                # Copy core run properties
                self._copy_core_run_properties(run, new_run)
                
                # Copy extended run properties
                self._copy_extended_run_properties(run, new_run)
                
                # Copy font properties
                self._copy_font_properties(run, new_run)
                
                # Copy style if it exists
                if hasattr(run, 'style') and run.style:
                    try:
                        new_run.style = run.style
                    except Exception as e:
                        print(f"Could not copy run style: {e}")
            
            # Copy paragraph style and properties
            self._copy_paragraph_properties(para, new_para)
                
        return new_doc
    
    def _copy_core_run_properties(self, source_run, target_run) -> None:
        """
        Copy the core run properties that are guaranteed to exist in python-docx.
        
        Args:
            source_run: Source run to copy from
            target_run: Target run to copy to
        """
        core_properties = ['bold', 'italic', 'underline']
        
        for prop in core_properties:
            try:
                setattr(target_run, prop, getattr(source_run, prop))
            except Exception as e:
                print(f"Could not copy core property {prop}: {e}")
    
    def _copy_extended_run_properties(self, source_run, target_run) -> None:
        """
        Copy extended run properties with validation.
        
        Args:
            source_run: Source run to copy from
            target_run: Target run to copy to
        """
        extended_properties = [
            'all_caps', 'double_strike', 'emboss', 'imprint',
            'outline', 'shadow', 'small_caps', 'strike',
            'subscript', 'superscript'
        ]
        
        for prop in extended_properties:
            try:
                if hasattr(source_run, prop):
                    setattr(target_run, prop, getattr(source_run, prop))
            except Exception as e:
                print(f"Could not copy extended property {prop}: {e}")
    
    def _copy_font_properties(self, source_run, target_run) -> None:
        """
        Copy font properties with comprehensive handling of colors and highlighting.
        
        Args:
            source_run: Source run to copy from
            target_run: Target run to copy to
        """
        if not hasattr(source_run, 'font') or not hasattr(target_run, 'font'):
            return
            
        # Copy basic font properties
        if source_run.font.name:
            target_run.font.name = source_run.font.name
            
        if source_run.font.size:
            target_run.font.size = source_run.font.size
        
        # Handle text color (foreground)
        try:
            if hasattr(source_run.font, 'color'):
                if source_run.font.color.rgb is not None:
                    target_run.font.color.rgb = source_run.font.color.rgb
                elif hasattr(source_run.font.color, 'theme_color'):
                    target_run.font.color.theme_color = source_run.font.color.theme_color
        except Exception as e:
            print(f"Could not copy font color: {e}")
            
        # Handle highlighting (background)
        try:
            if hasattr(source_run.font, 'highlight_color'):
                if source_run.font.highlight_color:
                    target_run.font.highlight_color = source_run.font.highlight_color
        except Exception as e:
            print(f"Could not copy highlight color: {e}")
            
        # Handle background color/shading using XML (for non-highlight background colors)
        try:
            # Import here to avoid dependencies at module level
            from docx.oxml.ns import qn
            
            # Get XML elements
            source_element = source_run._element
            target_element = target_run._element
            
            # Look for shading in source run's properties
            source_props = source_element.get_or_add_rPr()
            source_shd = source_props.find(qn('w:shd'))
            
            if source_shd is not None:
                # Source has custom background shading
                # Get target run properties
                target_props = target_element.get_or_add_rPr()
                
                # Check if target already has shading
                target_shd = target_props.find(qn('w:shd'))
                
                # If target already has shading, remove it (we'll copy the new one)
                if target_shd is not None:
                    target_props.remove(target_shd)
                    
                # Copy the shading properties from source to target
                from copy import deepcopy
                new_shd = deepcopy(source_shd)
                target_props.append(new_shd)
        except Exception as e:
            print(f"Could not copy background shading: {e}")
    
    def _copy_paragraph_properties(self, source_para, target_para) -> None:
        """
        Copy paragraph style, properties, and shading with validation.
        
        Args:
            source_para: Source paragraph to copy from
            target_para: Target paragraph to copy to
        """
        # Copy style if it exists
        if source_para.style:
            try:
                target_para.style = source_para.style
            except Exception as e:
                print(f"Could not copy paragraph style: {e}")
        
        # Handle paragraph shading/background
        try:
            if hasattr(source_para._element, 'pPr'):
                source_pPr = source_para._element.pPr
                if hasattr(source_pPr, 'shd'):
                    shading = source_pPr.shd
                    if shading is not None and hasattr(target_para._element, 'pPr'):
                        # Ensure pPr exists in target
                        if target_para._element.pPr is None:
                            target_para._element.get_or_add_pPr()
                        # Copy shading element
                        target_para._element.pPr.shd = shading
        except Exception as e:
            print(f"Could not copy paragraph shading: {e}")
        
        # Copy paragraph format properties if they exist
        if hasattr(source_para, 'paragraph_format') and hasattr(target_para, 'paragraph_format'):
            format_properties = [
                'alignment', 'first_line_indent', 'keep_together',
                'keep_with_next', 'left_indent', 'line_spacing',
                'right_indent', 'space_after', 'space_before'
            ]
            
            for prop in format_properties:
                try:
                    source_value = getattr(source_para.paragraph_format, prop)
                    if source_value is not None:
                        setattr(target_para.paragraph_format, prop, source_value)
                except Exception as e:
                    print(f"Could not copy paragraph format property {prop}: {e}")
    
    def _create_zip_archive(self, output_dir: Path, preserve_hierarchy: bool = False) -> Path:
        """Create zip archive with section documents using parallel processing for faster execution."""
        import concurrent.futures
        import json
        from threading import Lock
        
        zip_path = output_dir / f"{self.input_path.stem}_sections.zip"
        total_sections = len(self.sections)
        
        # Use temporary directory for intermediate files
        with TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            progress_lock = Lock()
            file_entries = []
            
            # Function to process a single section in a worker thread
            def process_section(task):
                idx, section = task
                
                if self.cancel_requested:
                    return None
                    
                # Result dict to track progress and collect file paths
                result = {
                    "success": False,
                    "section_title": section.safe_title,
                    "error": None,
                    "temp_file": None,
                    "archive_path": None,
                    "meta_file": None,
                    "meta_archive_path": None
                }
                
                try:
                    # Create document for section
                    doc = self._create_section_document(section)
                    
                    # Add hierarchy metadata and get metadata dict
                    metadata = self._add_document_metadata(doc, section, self.sections)
                    
                    # Determine path within zip based on hierarchy option
                    if preserve_hierarchy and section.parent:
                        # Get folder structure from parent hierarchy
                        folder_components = section.get_path_components()
                        
                        # Create base temp file path 
                        section_dir = temp_path
                        with progress_lock:  # Thread-safe directory creation
                            for component in folder_components:
                                section_dir = section_dir / component
                                section_dir.mkdir(exist_ok=True, parents=True)
                        
                        temp_file = section_dir / f"{section.safe_title}.docx"
                        
                        # Create archive path with folders
                        archive_path = '/'.join(folder_components + [f"{section.safe_title}.docx"])
                    else:
                        # No hierarchy - flat structure
                        temp_file = temp_path / f"{section.safe_title}.docx"
                        archive_path = temp_file.name
                    
                    # Save to temp file
                    doc.save(temp_file)
                    result["temp_file"] = temp_file
                    result["archive_path"] = archive_path
                    
                    # Create a separate metadata file
                    if metadata:
                        meta_file = temp_path / f"{section.safe_title}.meta.json"
                        with open(meta_file, 'w', encoding='utf-8') as f:
                            json.dump(metadata, f, indent=2)
                        
                        result["meta_file"] = meta_file
                        result["meta_archive_path"] = archive_path + ".meta.json"
                    
                    result["success"] = True
                    
                except Exception as e:
                    result["error"] = str(e)
                
                return result
            
            # Prepare tasks for parallel processing
            tasks = [(i, section) for i, section in enumerate(self.sections, 1)]
            
            # Calculate optimal number of workers
            max_workers = min(os.cpu_count() or 4, max(1, 32 if total_sections < 100 else 16))
            self.status_callback(f"Creating documents using {max_workers} parallel workers...")
            
            # Process sections in parallel first to create all necessary files
            completed = 0
            with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
                # Submit all tasks
                future_to_idx = {executor.submit(process_section, task): task[0] for task in tasks}
                
                # Process results as they complete
                for future in concurrent.futures.as_completed(future_to_idx):
                    idx = future_to_idx[future]
                    
                    try:
                        result = future.result()
                        if result is None:  # Cancellation
                            continue
                            
                        completed += 1
                        
                        # Update progress
                        with progress_lock:
                            percent_complete = int(completed / total_sections * 100)
                            self.progress_callback(percent_complete)
                            
                            # Get shortened section title for status
                            section_title = result["section_title"]
                            if len(section_title) > 30:
                                section_title = section_title[:27] + "..."
                            
                            # Update UI
                            if result["success"]:
                                self.status_callback(f"Created document {completed}/{total_sections}: '{section_title}'")
                                # Add to entries list for zip creation
                                if result["temp_file"] and result["archive_path"]:
                                    file_entries.append((result["temp_file"], result["archive_path"]))
                                    if result["meta_file"] and result["meta_archive_path"]:
                                        file_entries.append((result["meta_file"], result["meta_archive_path"]))
                            else:
                                self.status_callback(f"Error processing {idx}/{total_sections}: '{section_title}' - {result['error']}")
                        
                        # Check for cancellation
                        if self.cancel_requested:
                            executor.shutdown(wait=False, cancel_futures=True)
                            self.status_callback("Operation canceled - stopping all processing")
                            return None
                            
                    except Exception as e:
                        with progress_lock:
                            self.status_callback(f"Error in worker {idx}: {str(e)}")
            
            # Check if processing was canceled
            if self.cancel_requested:
                self.status_callback("Operation canceled while processing documents")
                return None
                
            # Create the zip file now that all documents have been generated
            self.status_callback(f"Creating ZIP archive with {len(file_entries)} files...")
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as archive:
                for temp_file, archive_path in file_entries:
                    try:
                        archive.write(temp_file, archive_path)
                    except Exception as e:
                        self.status_callback(f"Error adding {temp_file.name} to archive: {str(e)}")
                        
            self.status_callback(f"Created archive at: {zip_path}")
            return zip_path
    
    def _save_individual_files(self, output_dir: Path, preserve_hierarchy: bool = False) -> Path:
        """Save individual document files with parallel processing for improved performance."""
        import concurrent.futures
        import json
        from threading import Lock
        
        total_sections = len(self.sections)
        files_created = 0
        progress_lock = Lock()
        
        # Create source document subfolder
        source_doc_name = self.input_path.stem
        source_doc_folder = output_dir / source_doc_name
        source_doc_folder.mkdir(parents=True, exist_ok=True)
        
        # Create source metadata file
        self._create_source_metadata_file(source_doc_folder, preserve_hierarchy)
        
        # Initial status update for document creation phase
        self.status_callback(f"Creating {total_sections} individual documents in {source_doc_name}/ folder...")
        
        # Function to process a single section in a worker thread
        def process_section(task):
            idx, section = task
            
            if self.cancel_requested:
                return None
                
            # Progress tracking variables that will be returned from worker
            result = {
                "success": False,
                "section_title": section.safe_title,
                "error": None,
                "output_file": None
            }
            
            try:
                # Create document for section - most time-consuming part
                doc = self._create_section_document(section)
                
                # Add hierarchy metadata
                metadata = self._add_document_metadata(doc, section, self.sections)
                
                # Determine output path based on hierarchy option
                if preserve_hierarchy and section.parent is not None:
                    # Get folder path components
                    folder_components = section.get_path_components()
                    section_dir = source_doc_folder  # Use source doc folder as base
                    
                    # Create directories if they don't exist
                    for component in folder_components:
                        section_dir = section_dir / component
                        with progress_lock:  # Prevent race conditions in directory creation
                            section_dir.mkdir(exist_ok=True, parents=True)
                    
                    output_file = section_dir / f"{section.safe_title}.docx"
                    
                    # Create metadata file path
                    if metadata:
                        meta_file_path = section_dir / f"{section.safe_title}.meta.json"
                else:
                    # Flat structure - save directly to source doc folder
                    output_file = source_doc_folder / f"{section.safe_title}.docx"
                    
                    # Create metadata file path
                    if metadata:
                        meta_file_path = source_doc_folder / f"{section.safe_title}.meta.json"
                
                # Write metadata file if we have metadata
                if metadata:
                    with progress_lock:  # Prevent race conditions in file writing
                        with open(meta_file_path, 'w', encoding='utf-8') as f:
                            json.dump(metadata, f, indent=2)
                
                # Save the document
                doc.save(output_file)
                
                # Update result status
                result["success"] = True
                result["output_file"] = str(output_file)
                
            except Exception as e:
                result["error"] = str(e)
                
            return result
        
        # Prepare tasks for parallel processing
        tasks = [(i, section) for i, section in enumerate(self.sections, 1)]
        
        # Calculate optimal number of workers based on CPU count and document size
        # For very large documents with many sections, limit worker count to prevent memory issues
        max_workers = min(os.cpu_count() or 4, max(1, 32 if total_sections < 100 else 16))
        self.status_callback(f"Using {max_workers} parallel workers for document creation")
        
        # Process sections in parallel
        completed = 0
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # Submit all tasks
            future_to_idx = {executor.submit(process_section, task): task[0] for task in tasks}
            
            # Process results as they complete
            for future in concurrent.futures.as_completed(future_to_idx):
                idx = future_to_idx[future]
                
                try:
                    result = future.result()
                    if result is None:  # Cancellation
                        continue
                        
                    completed += 1
                    
                    # Update progress
                    with progress_lock:
                        percent_complete = int(completed / total_sections * 100)
                        self.progress_callback(percent_complete)
                        
                        # Get shortened section title for status
                        section_title = result["section_title"]
                        if len(section_title) > 30:
                            section_title = section_title[:27] + "..."
                        
                        # Update UI
                        if result["success"]:
                            files_created += 1
                            self.status_callback(f"Processed {completed}/{total_sections}: '{section_title}'")
                        else:
                            self.status_callback(f"Error processing {idx}/{total_sections}: '{section_title}' - {result['error']}")
                    
                    # Check for cancellation
                    if self.cancel_requested:
                        executor.shutdown(wait=False, cancel_futures=True)
                        self.status_callback("Operation canceled - stopping all processing")
                        return None
                        
                except Exception as e:
                    with progress_lock:
                        self.status_callback(f"Error in worker {idx}: {str(e)}")
        
        if self.cancel_requested:
            self.status_callback("Operation canceled while saving files")
            return None
                
        self.status_callback(f"Saved {files_created} documents to: {source_doc_folder}")
        return source_doc_folder
    
    def _create_source_metadata_file(self, source_doc_folder: Path, preserve_hierarchy: bool):
        """Create metadata file with source document information."""
        source_doc_name = self.input_path.stem
        metadata_filename = f"{source_doc_name}_metadata.json"
        metadata_path = source_doc_folder / metadata_filename
        
        # Get current heading level from sections
        heading_level = 3  # Default
        if self.sections:
            heading_level = self.sections[0].level
        
        metadata = {
            "source_document_path": str(self.input_path.absolute()),
            "template_path": str(self.template_path.absolute()),
            "heading_level": heading_level,
            "preserve_hierarchy": preserve_hierarchy,
            "created_timestamp": datetime.now().isoformat()
        }
        
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2)
        
        print(f"CREATED METADATA: {metadata_filename}")

class QueueItemWidget(QWidget):
    """Widget to display a queue item with controls."""
    
    destination_changed = pyqtSignal(int, str)  # Index, new path
    remove_requested = pyqtSignal(int)  # Index
    
    def __init__(self, queue_item: SplitQueueItem, index: int, parent=None):
        super().__init__(parent)
        self.queue_item = queue_item
        self.index = index
        self.setup_ui()
        self.update_status()
        
    def setup_ui(self):
        """Set up the widget UI."""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        
        # File info
        info_layout = QVBoxLayout()
        self.file_label = QLabel(f"<b>{self.queue_item.display_name}</b>")
        self.file_label.setTextFormat(Qt.TextFormat.RichText)
        
        # Status and progress
        status_layout = QHBoxLayout()
        self.status_label = QLabel("Status: Queued")
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setFixedHeight(15)
        
        status_layout.addWidget(self.status_label)
        status_layout.addWidget(self.progress_bar, 1)
        
        info_layout.addWidget(self.file_label)
        info_layout.addLayout(status_layout)
        
        # Destination
        dest_layout = QHBoxLayout()
        dest_label = QLabel("Destination:")
        self.dest_field = QLineEdit(str(self.queue_item.output_dir))
        self.dest_field.setReadOnly(True)
        self.dest_button = QPushButton("Change...")
        self.dest_button.clicked.connect(self.change_destination)
        
        dest_layout.addWidget(dest_label)
        dest_layout.addWidget(self.dest_field, 1)
        dest_layout.addWidget(self.dest_button)
        
        info_layout.addLayout(dest_layout)
        
        # Add info layout to main layout
        layout.addLayout(info_layout, 1)
        
        # Remove button
        self.remove_button = QPushButton("Remove")
        self.remove_button.clicked.connect(lambda: self.remove_requested.emit(self.index))
        layout.addWidget(self.remove_button)
        
        # Set fixed height
        self.setFixedHeight(100)
        
        # Add border
        self.setStyleSheet(
            "QWidget { border: 1px solid #cccccc; border-radius: 4px; background-color: #f9f9f9; }"
        )
    
    def update_status(self):
        """Update status display based on queue item state."""
        status_map = {
            "queued": "Queued",
            "parsing": "Parsing",
            "processing": "Processing",
            "completed": "Completed",
            "error": "Error"
        }
        
        status_text = status_map.get(self.queue_item.status, "Unknown")
        self.status_label.setText(f"Status: {status_text}")
        
        if self.queue_item.error:
            self.status_label.setText(f"Status: Error - {self.queue_item.error}")
            self.status_label.setStyleSheet("color: red;")
        
        self.progress_bar.setValue(self.queue_item.progress)
        
        # Disable controls if processing or completed
        is_active = self.queue_item.status in ("processing", "completed")
        self.dest_button.setEnabled(not is_active)
        self.remove_button.setEnabled(not is_active)
        
        # Update destination field
        self.dest_field.setText(str(self.queue_item.output_dir))
    
    def update_status_message(self, message):
        """Update status display with a custom message."""
        self.status_label.setText(f"Status: {message}")
        
    def update_progress(self, percent):
        """Update progress bar."""
        self.progress_bar.setValue(percent)
        if hasattr(self.queue_item, 'progress'):
            self.queue_item.progress = percent
    
    def set_completed(self, result_path):
        """Set item as completed."""
        self.queue_item.status = "completed"
        self.queue_item.result_path = result_path
        self.queue_item.progress = 100
        self.update_status()
        
    def set_error(self, error_message):
        """Set item as error."""
        self.queue_item.status = "error"
        self.queue_item.error = error_message
        self.update_status()
    
    def change_destination(self):
        """Open dialog to change destination directory."""
        directory = QFileDialog.getExistingDirectory(
            self,
            "Select Output Directory",
            str(self.queue_item.output_dir)
        )
        
        if directory:
            self.queue_item.output_dir = Path(directory)
            self.dest_field.setText(directory)
            self.destination_changed.emit(self.index, directory)


class AddToIndexDialog(QDialog):
    """
    Dialog for adding documents to the index by splitting Word documents by heading level.
    Supports queue-based batch processing of multiple documents.
    """
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Add Files to Index")
        self.setMinimumSize(800, 600)  # Larger size to accommodate queue
        
        # Initialize state variables
        self.input_path = None
        self.template_path = None
        self.output_dir = None
        self.queue_items = []  # List of SplitQueueItem objects
        self.queue_widgets = []  # List of QueueItemWidget objects
        self.is_processing = False
        
        # Threading components
        self.worker = None
        self.worker_thread = None
        
        # Get application settings
        self.settings = QSettings('DocxSearchApp', 'Settings')
        
        # Setup UI
        self.setup_ui()
        
        # Load previous settings
        self.load_settings()

        # Reference to the current splitter
        self.current_splitter = None
    
    def setup_ui(self):
        """Initialize the user interface with queue management."""
        layout = QVBoxLayout(self)
        
        # Create tab widget for document selection and queue
        tab_widget = QTabWidget()
        layout.addWidget(tab_widget)
        
        # Document selection tab
        doc_selection_tab = QWidget()
        doc_layout = QVBoxLayout(doc_selection_tab)
        
        # Input document selection
        input_group = QFrame()
        input_layout = QHBoxLayout(input_group)
        
        input_label = QLabel("Input Document:")
        self.input_field = QLineEdit()
        self.input_field.setReadOnly(True)
        self.input_field.setPlaceholderText("Select a Word document to split")
        
        input_button = QPushButton("Browse...")
        input_button.clicked.connect(self.browse_input_document)
        
        input_layout.addWidget(input_label)
        input_layout.addWidget(self.input_field, 1)
        input_layout.addWidget(input_button)
        
        doc_layout.addWidget(input_group)
        
        # Template document selection
        template_group = QFrame()
        template_layout = QHBoxLayout(template_group)
        
        template_label = QLabel("Template Document:")
        self.template_field = QLineEdit()
        self.template_field.setReadOnly(True)
        self.template_field.setPlaceholderText("Select a template document (optional)")
        
        template_button = QPushButton("Browse...")
        template_button.clicked.connect(self.browse_template_document)
        
        template_layout.addWidget(template_label)
        template_layout.addWidget(self.template_field, 1)
        template_layout.addWidget(template_button)
        
        doc_layout.addWidget(template_group)
        
        # Heading level selection
        level_group = QFrame()
        level_layout = QHBoxLayout(level_group)
        
        level_label = QLabel("Split at Heading Level:")
        self.level_combo = QComboBox()
        for i in range(1, 5):  # Heading levels 1-4 only
            self.level_combo.addItem(f"Heading {i}", i)
        
        # Default to heading level 3
        self.level_combo.setCurrentIndex(2)  # 0-based index, so 2 = Heading 3
        
        level_layout.addWidget(level_label)
        level_layout.addWidget(self.level_combo)
        level_layout.addStretch(1)
        
        doc_layout.addWidget(level_group)
        
        # Output options
        output_group = QFrame()
        output_layout = QVBoxLayout(output_group)
        
        self.zip_checkbox = QCheckBox("Create ZIP archive of documents")
        self.zip_checkbox.setChecked(True)
        output_layout.addWidget(self.zip_checkbox)
        
        self.preserve_hierarchy_checkbox = QCheckBox("Preserve file organization using folders")
        self.preserve_hierarchy_checkbox.setChecked(False)
        output_layout.addWidget(self.preserve_hierarchy_checkbox)

        output_dir_frame = QFrame()
        output_dir_layout = QHBoxLayout(output_dir_frame)
        
        output_label = QLabel("Output Location:")
        self.output_field = QLineEdit()
        self.output_field.setReadOnly(True)
        self.output_field.setPlaceholderText("Select output directory")
        
        output_button = QPushButton("Browse...")
        output_button.clicked.connect(self.browse_output_directory)
        
        output_dir_layout.addWidget(output_label)
        output_dir_layout.addWidget(self.output_field, 1)
        output_dir_layout.addWidget(output_button)
        
        output_layout.addWidget(output_dir_frame)
        doc_layout.addWidget(output_group)
        
        # Add to queue button
        add_button = QPushButton("Add to Queue")
        add_button.clicked.connect(self.add_to_queue)
        doc_layout.addWidget(add_button)
        
        # Add document selection tab
        tab_widget.addTab(doc_selection_tab, "Select Document")
        
        # Queue management tab
        queue_tab = QWidget()
        queue_layout = QVBoxLayout(queue_tab)
        
        # Queue list container with scrolling
        queue_scroll = QScrollArea()
        queue_scroll.setWidgetResizable(True)
        queue_scroll.setFrameShape(QFrame.Shape.NoFrame)
        
        self.queue_container = QWidget()
        self.queue_list_layout = QVBoxLayout(self.queue_container)
        self.queue_list_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        self.queue_list_layout.setSpacing(10)
        
        queue_scroll.setWidget(self.queue_container)
        queue_layout.addWidget(queue_scroll)
        
        # Queue controls
        queue_controls = QHBoxLayout()
        
        self.start_queue_button = QPushButton("Start Processing Queue")
        self.start_queue_button.clicked.connect(self.process_queue)
        self.start_queue_button.setEnabled(False)  # Disabled until queue has items
        
        self.clear_queue_button = QPushButton("Clear Queue")
        self.clear_queue_button.clicked.connect(self.clear_queue)
        self.clear_queue_button.setEnabled(False)  # Disabled until queue has items
        
        self.clear_completed_button = QPushButton("Clear Completed")
        self.clear_completed_button.clicked.connect(self.clear_completed_items)
        self.clear_completed_button.setEnabled(False)  # Disabled until items are completed
        
        queue_controls.addWidget(self.start_queue_button)
        queue_controls.addWidget(self.clear_queue_button)
        queue_controls.addWidget(self.clear_completed_button)
        
        queue_layout.addLayout(queue_controls)
        
        # Add queue tab
        tab_widget.addTab(queue_tab, "Queue")
        
        # Status display
        self.status_text = QLabel("Ready")
        layout.addWidget(self.status_text)
        
        # Overall progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)
        
        # Dialog buttons
        button_box = QHBoxLayout()
        
        # Close button
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.close)  # This should trigger the closeEvent
        button_box.addWidget(close_button)
        
        layout.addLayout(button_box)
    
    def load_settings(self):
        """Load previous settings."""
        # Load template path
        template_path = self.settings.value('document_splitter/template_path')
        if template_path:
            self.template_path = Path(template_path)
            self.template_field.setText(str(self.template_path))
        
        # Load output directory
        output_dir = self.settings.value('document_splitter/output_dir')
        if output_dir:
            self.output_dir = Path(output_dir)
            self.output_field.setText(str(self.output_dir))
        
        # Load heading level
        level = self.settings.value('document_splitter/heading_level', type=int)
        if level:
            # Find index of the level in the combo box
            for i in range(self.level_combo.count()):
                if self.level_combo.itemData(i) == level:
                    self.level_combo.setCurrentIndex(i)
                    break
        
        # Load zip option
        create_zip = self.settings.value('document_splitter/create_zip', type=bool)
        if create_zip is not None:  # Check for None since this is a boolean
            self.zip_checkbox.setChecked(create_zip)
    
        # Load hierarchy option
        preserve_hierarchy = self.settings.value('document_splitter/preserve_hierarchy', type=bool)
        if preserve_hierarchy is not None:
            self.preserve_hierarchy_checkbox.setChecked(preserve_hierarchy)

    def save_settings(self):
        """Save current settings."""
        # Save template path
        if self.template_path:
            self.settings.setValue('document_splitter/template_path', str(self.template_path))
        
        # Save output directory
        if self.output_dir:
            self.settings.setValue('document_splitter/output_dir', str(self.output_dir))
        
        # Save heading level
        level = self.level_combo.currentData()
        self.settings.setValue('document_splitter/heading_level', level)
        
        # Save zip option
        self.settings.setValue('document_splitter/create_zip', self.zip_checkbox.isChecked())
    
        # Save hierarchy option
        self.settings.setValue('document_splitter/preserve_hierarchy', 
                               self.preserve_hierarchy_checkbox.isChecked())

    def closeEvent(self, event):
        """Handle dialog close event."""
        print("closeEvent triggered!")  # Debug
        
        # Check if there's an active operation
        if self.current_splitter is not None and not self.process_button.isEnabled():
            print(f"Active operation detected! current_splitter={self.current_splitter}")
            reply = QMessageBox.question(
                self,
                "Cancel Operation",
                "A document split operation is in progress.\nDo you want to cancel it?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                print("User confirmed cancellation")
                # Cancel the operation
                self.update_status("Canceling operation...")
                print("About to call current_splitter.cancel()")  # Debug
                self.current_splitter.cancel()
                print("Called current_splitter.cancel()")  # Debug
                
                # Wait briefly for cancellation to take effect
                QTimer.singleShot(500, self.cleanup_and_close)
                event.ignore()  # Don't close yet, wait for cleanup
            else:
                event.ignore()  # Don't close if user doesn't want to cancel
        else:
            print(f"No active operation detected: current_splitter={self.current_splitter}, button enabled={self.process_button.isEnabled()}")
            # Save settings before closing
            self.save_settings()
            event.accept()
    
    def cleanup_and_close(self):
        """Clean up resources and close the dialog."""
        self.current_splitter = None
        self.process_button.setEnabled(True)
        self.progress_bar.setVisible(False)
        self.update_status("Operation canceled")
        self.close()  # Now we can close

    def browse_input_document(self):
        """Browse for input document."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Document to Split",
            "",
            "Word Documents (*.docx)"
        )
        
        if file_path:
            self.input_path = Path(file_path)
            self.input_field.setText(str(self.input_path))
            
            # Set default output directory to input file's directory
            if not self.output_dir:
                self.output_dir = self.input_path.parent
                self.output_field.setText(str(self.output_dir))
                # Save this setting
                self.save_settings()
    
    def browse_template_document(self):
        """Browse for template document."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Template Document",
            "",
            "Word Documents (*.docx)"
        )
        
        if file_path:
            self.template_path = Path(file_path)
            self.template_field.setText(str(self.template_path))
            # Save this setting
            self.save_settings()
    
    def browse_output_directory(self):
        """Browse for output directory."""
        directory = QFileDialog.getExistingDirectory(
            self,
            "Select Output Directory",
            str(self.output_dir) if self.output_dir else ""
        )
        
        if directory:
            self.output_dir = Path(directory)
            self.output_field.setText(str(self.output_dir))
            # Save this setting
            self.save_settings()
    
    def update_status(self, message):
        """Update status display."""
        self.status_text.setText(message)
        QApplication.processEvents()  # Ensure UI updates

    def update_progress(self, percent):
        """Update progress bar."""
        self.progress_bar.setValue(percent)
        QApplication.processEvents()  # Ensure UI updates
        
    def getDocxSplitter(self):
        """Get the current DocxSplitter instance if any."""
        return self.current_splitter

    def add_to_queue(self):
        """Add current document and settings to the processing queue."""
        # Validate inputs
        if not self.input_path or not self.input_path.exists():
            QMessageBox.warning(
                self,
                "Missing Input",
                "Please select a valid input document to add to the queue."
            )
            return
            
        if not self.output_dir:
            QMessageBox.warning(
                self,
                "Missing Output Location",
                "Please select an output location before adding to the queue."
            )
            return
        
        # Create template if not provided
        template_path = self.template_path
        if not template_path:
            # Create default template
            try:
                default_doc = docx.Document()
                with TemporaryDirectory() as temp_dir:
                    temp_path = Path(temp_dir)
                    template_path = temp_path / "default_template.docx"
                    default_doc.save(template_path)
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to create default template: {str(e)}"
                )
                return
        
        # Create a queue item
        queue_item = SplitQueueItem(
            input_path=self.input_path,
            template_path=template_path,
            output_dir=self.output_dir,
            heading_level=self.level_combo.currentData(),
            create_zip=self.zip_checkbox.isChecked(),
            preserve_hierarchy=self.preserve_hierarchy_checkbox.isChecked()
        )
        
        # Add to queue list
        self.queue_items.append(queue_item)
        self._add_queue_widget(queue_item)
        
        # Enable queue buttons
        self.clear_queue_button.setEnabled(True)
        
        # If not currently processing, enable the start button
        # otherwise the new item will be picked up by the running process
        if not self.is_processing:
            self.start_queue_button.setEnabled(True)
        
        # Switch to queue tab
        tab_widget = self.findChild(QTabWidget)
        tab_widget.setCurrentIndex(1)  # Switch to queue tab (0-indexed)
        
        # Save settings
        self.save_settings()
        
        # Update status
        self.update_status(f"Added {self.input_path.name} to queue")
    
    def _add_queue_widget(self, queue_item):
        """Add a widget to display a queue item."""
        widget = QueueItemWidget(queue_item, len(self.queue_widgets))
        widget.destination_changed.connect(self.on_destination_changed)
        widget.remove_requested.connect(self.remove_queue_item)
        
        self.queue_list_layout.addWidget(widget)
        self.queue_widgets.append(widget)
    
    def on_destination_changed(self, index, new_path):
        """Handle destination directory change for a queue item."""
        if 0 <= index < len(self.queue_items):
            self.queue_items[index].output_dir = Path(new_path)
            self.update_status(f"Changed destination for item #{index+1}")
    
    def remove_queue_item(self, index):
        """Remove an item from the queue."""
        if 0 <= index < len(self.queue_items):
            # Remove the widget from layout
            widget = self.queue_widgets[index]
            self.queue_list_layout.removeWidget(widget)
            widget.deleteLater()
            
            # Remove from data lists
            self.queue_items.pop(index)
            self.queue_widgets.pop(index)
            
            # Update indexes of remaining widgets
            for i, widget in enumerate(self.queue_widgets):
                widget.index = i
            
            # Update UI state
            if not self.queue_items:
                self.start_queue_button.setEnabled(False)
                self.clear_queue_button.setEnabled(False)
            
            self.update_status(f"Removed item from queue")
    
    def clear_queue(self):
        """Clear all items from the queue."""
        if not self.queue_items:
            return
            
        if self.is_processing:
            reply = QMessageBox.question(
                self,
                "Queue Processing Active",
                "Processing is currently active. Stopping will cancel the current operation.\n\n"
                "Do you want to stop processing and clear the queue?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply != QMessageBox.StandardButton.Yes:
                return
            
            # Cancel current processing
            if self.current_splitter:
                self.current_splitter.cancel()
                self.current_splitter = None
            self.is_processing = False
        
        # Clear all widgets
        for widget in self.queue_widgets:
            self.queue_list_layout.removeWidget(widget)
            widget.deleteLater()
        
        # Clear data lists
        self.queue_items.clear()
        self.queue_widgets.clear()
        
        # Update UI
        self.start_queue_button.setEnabled(False)
        self.clear_queue_button.setEnabled(False)
        self.clear_completed_button.setEnabled(False)
        self.progress_bar.setVisible(False)
        
        self.update_status("Queue cleared")
    
    def clear_completed_items(self):
        """Remove completed items from the queue."""
        completed_indexes = []
        
        # Find completed items (in reverse order to handle removal)
        for i in range(len(self.queue_items) - 1, -1, -1):
            if self.queue_items[i].status in ["completed", "error"]:
                completed_indexes.append(i)
        
        # Remove each completed item
        for index in completed_indexes:
            self.remove_queue_item(index)
        
        # Update UI
        if completed_indexes:
            self.clear_completed_button.setEnabled(False)
            self.update_status(f"Removed {len(completed_indexes)} completed items")
    
    def process_queue(self):
        """Start processing the queue using a background thread."""
        if not self.queue_items:
            return
        
        if self.is_processing:
            # Stop processing if already running
            self.stop_processing()
            return
        
        # Find the first queued item
        start_index = -1
        for i, item in enumerate(self.queue_items):
            if item.status == "queued":
                start_index = i
                break
                
        if start_index == -1:
            QMessageBox.information(
                self,
                "No Items to Process",
                "No queued items were found to process."
            )
            return
        
        # Set processing state
        self.is_processing = True
        self.start_queue_button.setText("Stop Processing")
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        
        # Create worker and thread
        self.worker = DocxSplitterWorker(self.queue_items, start_index)
        self.worker_thread = QThread()
        self.worker.moveToThread(self.worker_thread)
        
        # Connect signals
        self.worker_thread.started.connect(self.worker.process_queue)
        self.worker.status_changed.connect(self.on_worker_status_changed)
        self.worker.progress_updated.connect(self.on_worker_progress_updated)
        self.worker.item_completed.connect(self.on_worker_item_completed)
        self.worker.item_error.connect(self.on_worker_item_error)
        self.worker.all_completed.connect(self.on_worker_all_completed)
        
        # Start the thread
        self.worker_thread.start()
        self.update_status(f"Started processing queue at item #{start_index+1}")
        
    def stop_processing(self):
        """Stop the current queue processing."""
        if not self.is_processing or not self.worker:
            return
            
        reply = QMessageBox.question(
            self,
            "Stop Processing",
            "Are you sure you want to stop processing the queue?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply != QMessageBox.StandardButton.Yes:
            return
            
        # Cancel the worker
        self.worker.cancel()
        self.update_status("Stopping queue processing... Please wait")
        
        # The thread will signal completion which will clean up resources
        
    def on_worker_status_changed(self, index, message):
        """Handle status change from worker."""
        self.update_status(message)
        
        # Update the widget if it exists
        if 0 <= index < len(self.queue_widgets):
            # Nothing to do here - we don't display individual status messages in widgets
            pass
            
    def on_worker_progress_updated(self, index, percent):
        """Handle progress update from worker."""
        # Update the queue item
        if 0 <= index < len(self.queue_items):
            self.queue_items[index].progress = percent
            
            # Update the widget
            if 0 <= index < len(self.queue_widgets):
                self.queue_widgets[index].update_status()
                
        # Update overall progress
        total_items = len(self.queue_items)
        completed_items = sum(1 for item in self.queue_items if item.status in ["completed", "error"])
        in_progress_contribution = 0
        
        # Add contribution of current in-progress item
        if 0 <= index < len(self.queue_items) and self.queue_items[index].status == "processing":
            in_progress_contribution = percent / total_items
            
        overall_progress = int((completed_items / total_items * 100) + in_progress_contribution)
        self.progress_bar.setValue(overall_progress)
        
    def on_worker_item_completed(self, index, result_path, status):
        """Handle item completion from worker."""
        if 0 <= index < len(self.queue_items):
            self.queue_items[index].status = status
            self.queue_items[index].result_path = result_path
            self.queue_items[index].progress = 100
            
            # Update the widget
            if 0 <= index < len(self.queue_widgets):
                self.queue_widgets[index].update_status()
                
            self.update_status(f"Completed processing {self.queue_items[index].display_name}")
            self.clear_completed_button.setEnabled(True)
            
    def on_worker_item_error(self, index, error_message):
        """Handle item error from worker."""
        if 0 <= index < len(self.queue_items):
            self.queue_items[index].status = "error"
            self.queue_items[index].error = error_message
            
            # Update the widget
            if 0 <= index < len(self.queue_widgets):
                self.queue_widgets[index].update_status()
                
            self.update_status(f"Error processing {self.queue_items[index].display_name}: {error_message}")
            self.clear_completed_button.setEnabled(True)
            
    def on_worker_all_completed(self):
        """Handle completion of all queue items."""
        # Clean up
        if self.worker_thread and self.worker_thread.isRunning():
            self.worker_thread.quit()
            self.worker_thread.wait()  # Wait for the thread to finish
        
        self.worker_thread = None
        self.worker = None
        self.is_processing = False
        
        # Update UI
        self.start_queue_button.setText("Start Processing Queue")
        self.update_status("Queue processing complete")
        self.clear_completed_button.setEnabled(True)
        
        # Ensure progress bar is at 100%
        self.progress_bar.setValue(100)
    
    def _process_next_item(self):
        """Process the next item in the queue."""
        # Find first queued item
        next_index = -1
        for i, item in enumerate(self.queue_items):
            if item.status == "queued":
                next_index = i
                break
                
        if next_index == -1 or not self.is_processing:
            # No more items to process or processing was stopped
            self.is_processing = False
            self.start_queue_button.setText("Start Processing Queue")
            self.clear_completed_button.setEnabled(True)
            self.update_status("Queue processing complete")
            return
        
        # Update progress
        total_items = len(self.queue_items)
        completed_items = sum(1 for item in self.queue_items if item.status in ["completed", "error"])
        overall_progress = int((completed_items / total_items) * 100)
        self.progress_bar.setValue(overall_progress)
        
        # Get the item to process
        queue_item = self.queue_items[next_index]
        queue_widget = self.queue_widgets[next_index]
        
        # Update status
        queue_item.status = "processing"
        queue_widget.update_status()
        self.update_status(f"Processing {queue_item.display_name}")
        
        # Process the document
        self._process_document(queue_item, next_index)
    
    def _process_document(self, queue_item, index):
        """Process a specific document in the queue."""
        try:
            # Create a DocxSplitter instance
            self.current_splitter = DocxSplitter(
                queue_item.input_path,
                queue_item.template_path,
                status_callback=lambda msg: self._update_item_status(index, msg),
                progress_callback=lambda percent: self._update_item_progress(index, percent)
            )
            
            # Parse document sections
            self.current_splitter.parse_sections(queue_item.heading_level)
            
            # Check if operation was canceled
            if self.current_splitter.cancel_requested:
                queue_item.status = "error"
                queue_item.error = "Operation canceled"
                self.queue_widgets[index].update_status()
                self.current_splitter = None
                self._process_next_item()
                return
            
            # Process the document
            result_path = self.current_splitter.process_document(
                queue_item.output_dir,
                target_level=queue_item.heading_level,
                create_zip=queue_item.create_zip,
                preserve_hierarchy=queue_item.preserve_hierarchy
            )
            
            # Check if operation was canceled
            if result_path is None or self.current_splitter.cancel_requested:
                queue_item.status = "error"
                queue_item.error = "Operation canceled"
                self.queue_widgets[index].update_status()
                self.current_splitter = None
                self._process_next_item()
                return
            
            # Update queue item with result
            queue_item.result_path = result_path
            queue_item.status = "completed"
            queue_item.progress = 100
            self.queue_widgets[index].update_status()
            
            # Clear current splitter reference
            self.current_splitter = None
            
            # Process next item
            QTimer.singleShot(500, self._process_next_item)
            
        except Exception as e:
            # Handle errors
            queue_item.status = "error"
            queue_item.error = str(e)
            self.queue_widgets[index].update_status()
            self.current_splitter = None
            
            # Continue with next item
            QTimer.singleShot(500, self._process_next_item)
    
    def _update_item_status(self, index, message):
        """Update status message for a queue item."""
        if 0 <= index < len(self.queue_items):
            self.update_status(message)
    
    def _update_item_progress(self, index, percent):
        """Update progress for a queue item."""
        if 0 <= index < len(self.queue_items):
            self.queue_items[index].progress = percent
            self.queue_widgets[index].update_status()
    
    def closeEvent(self, event):
        """Handle dialog close event with queue processing check and cleanup."""
        print("closeEvent triggered!")  # Debug
        
        # First check if there's an active queue processing (thread running)
        if self.is_processing and self.worker_thread and self.worker_thread.isRunning():
            # Always cancel processing regardless of user choice
            reply = QMessageBox.information(
                self,
                "Canceling Processing",
                "Document queue processing will be stopped before closing.",
                QMessageBox.StandardButton.Ok
            )
            
            print("Stopping queue processing for application exit")
            self.update_status("Stopping queue processing...")
            
            # This is the critical part - we must ensure the threads are properly terminated
            # before the application closes
            
            # Step 1: Prevent any further processing
            self.is_processing = False
            if self.worker:
                self.worker.is_cancelled = True  # Force immediate cancel
                if hasattr(self.worker, 'current_splitter') and self.worker.current_splitter:
                    self.worker.current_splitter.cancel_requested = True  # Force cancel at deeper level
            
            # Step 2: Disconnect all signals completely
            if self.worker:
                try:
                    self.worker.status_changed.disconnect()
                    self.worker.progress_updated.disconnect()
                    self.worker.item_completed.disconnect()
                    self.worker.item_error.disconnect()
                    self.worker.all_completed.disconnect()
                    
                    # Also try to disconnect worker from the thread started signal
                    if self.worker_thread:
                        try:
                            self.worker_thread.started.disconnect(self.worker.process_queue)
                        except Exception:
                            pass
                except Exception as e:
                    print(f"Error disconnecting signals: {e}")
            
            # Step 3: Use a more aggressive thread termination approach
            if self.worker_thread and self.worker_thread.isRunning():
                print("Thread running, attempting termination")
                
                # Full thread termination sequence for more reliable shutdown
                print("Executing multi-step thread termination sequence")
                
                # Step 3.1: Try graceful quit first
                self.worker_thread.quit()
                if self.worker_thread.wait(300):  # Wait for 300ms
                    print("Thread terminated gracefully")
                else:
                    # Step 3.2: Try forceful termination
                    print("Thread still running after quit - using terminate()")
                    self.worker_thread.terminate()
                    
                    if self.worker_thread.wait(500):  # Wait up to 500ms
                        print("Thread terminated successfully")
                    else:
                        # Step 3.3: Most aggressive approach - system might vary in thread behavior
                        print("WARNING: Thread still running after terminate - using extreme measures")
                        try:
                            # Extra delay sometimes helps
                            QThread.msleep(100)
                            self.worker_thread.terminate()
                            self.worker_thread.wait(500)
                        except Exception as e:
                            print(f"Error during termination: {e}")
                        
                        if self.worker_thread.isRunning():
                            print("CRITICAL WARNING: Thread could not be terminated - this may cause a crash")
                        else:
                            print("Thread finally terminated")
                            
                # Additional safeguard - break all connections to worker
                if self.worker:
                    self.worker.is_cancelled = True  # One more time for good measure
                    
            # Step 4: Save settings and use a timer to force close
            self.save_settings()
            print("Using timer to force close the window")
            # Use a timer with longer delay to ensure all thread operations complete
            QTimer.singleShot(500, self.force_close_dialog)
            event.ignore()  # Don't close yet, let timer do it
            return  # Return early after handling
        else:
            # No active processing, just save settings and close normally
            self.save_settings()
            event.accept()
            return
        
        # Check for active individual processing (this is legacy from before threading)
        if self.current_splitter is not None and not self.start_queue_button.isEnabled():
            print(f"Active operation detected! current_splitter={self.current_splitter}")
            reply = QMessageBox.question(
                self,
                "Cancel Operation",
                "A document split operation is in progress.\nDo you want to cancel it?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                print("User confirmed cancellation")
                # Cancel the operation
                self.update_status("Canceling operation...")
                print("About to call current_splitter.cancel()")
                self.current_splitter.cancel()
                print("Called current_splitter.cancel()")
                
                # Wait briefly for cancellation to take effect
                QTimer.singleShot(500, self.cleanup_and_close)
                event.ignore()  # Don't close yet, wait for cleanup
            else:
                event.ignore()  # Don't close if user doesn't want to cancel
        else:
            print(f"No active operation detected: current_splitter={self.current_splitter}")
            # Save settings before closing
            self.save_settings()
            event.accept()
            
    def force_close_dialog(self):
        """Force close the dialog using QDialog's done method after ensuring threads are stopped."""
        # Do one final check for thread termination
        if hasattr(self, 'worker_thread') and self.worker_thread and self.worker_thread.isRunning():
            print("Thread still running before force close - terminating again")
            try:
                # More aggressive termination - safer to terminate again than to have a crash
                self.worker_thread.terminate()
                self.worker_thread.wait(100)
                
                # Final extreme measure - detach the thread to prevent crash
                if self.worker_thread.isRunning():
                    print("CRITICAL: Thread still running - detaching to prevent crash")
                    # Extreme measure - null out references
                    self.worker = None
                    self.worker_thread = None
            except Exception as e:
                print(f"Error during final termination: {e}")
                
        print("Force closing dialog with done(0)")
        self.done(0)  # Force dialog to close with accept result
    
    def cleanup_and_close(self):
        """Clean up resources and close the dialog."""
        # Set processing flag to false first
        self.is_processing = False
        
        # We need to cleanup worker and thread completely before continuing
        try:
            # Step 1: Force immediate cancellation at all levels
            if self.worker:
                self.worker.is_cancelled = True
                if hasattr(self.worker, 'current_splitter') and self.worker.current_splitter:
                    self.worker.current_splitter.cancel_requested = True
            
            # Step 2: Disconnect all signals completely
            if self.worker:
                try:
                    # Disconnect all worker signals
                    self.worker.status_changed.disconnect()
                    self.worker.progress_updated.disconnect()
                    self.worker.item_completed.disconnect()
                    self.worker.item_error.disconnect()
                    self.worker.all_completed.disconnect()
                    
                    # Also disconnect worker from thread started signal
                    if self.worker_thread:
                        try:
                            self.worker_thread.started.disconnect(self.worker.process_queue)
                        except Exception:
                            pass
                except Exception as e:
                    print(f"Error disconnecting signals: {e}")
            
            # Step 3: Terminate the thread (don't try quit+wait as it's not reliable enough)
            if self.worker_thread and self.worker_thread.isRunning():
                print("Directly terminating worker thread for clean exit")
                self.worker_thread.terminate()  # More aggressive but safer for clean exit
                
                # Wait for termination
                if not self.worker_thread.wait(1000):
                    print("WARNING: Thread could not be terminated!")
                else:
                    print("Thread terminated successfully")
                    
        except Exception as e:
            print(f"Error during thread cleanup: {e}")
        
        # Step 4: Clear all references
        self.worker = None
        self.worker_thread = None
        
        # Finally close the dialog - use done(0) which accepts the close event
        print("Cleanup complete, closing dialog with done(0)")
        self.save_settings()
        self.done(0)  # More reliable than close() - forces dialog to accept and close
        self.start_queue_button.setText("Start Processing Queue")
        self.progress_bar.setVisible(False)
        self.update_status("Operation canceled")
        
        # Save settings before closing
        self.save_settings()
        self.close()  # Now we can close


class UpdateIndexDialog(QDialog):
    """
    Dialog for updating the document index with two modes:
    1. Update All - Delete and rebuild from scratch
    2. Add New Only - Only add headings that don't already exist
    """
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Update Index")
        self.setMinimumSize(800, 600)
        
        # Initialize state variables
        self.input_path = None
        self.template_path = None
        self.output_dir = None
        self.queue_items = []
        self.queue_widgets = []
        self.is_processing = False
        self.update_mode = "add_new"  # "update_all" or "add_new"
        self.check_removed = False
        self.replacement_template_path = None  # For Update All tab
        
        # Threading components
        self.worker = None
        self.worker_thread = None
        
        # Get application settings
        self.settings = QSettings('DocxSearchApp', 'Settings')
        
        # Setup UI
        self.setup_ui()
        
        # Load previous settings
        self.load_settings()
        
        # Reference to the current splitter
        self.current_splitter = None
    
    def setup_ui(self):
        """Initialize the user interface with update-specific options."""
        layout = QVBoxLayout(self)
        
        # Create tab widget for document selection and queue
        tab_widget = QTabWidget()
        layout.addWidget(tab_widget)
        
        # Document selection tab
        doc_selection_tab = QWidget()
        doc_layout = QVBoxLayout(doc_selection_tab)
        
        # Update mode selection
        mode_group = QGroupBox("Update Mode")
        mode_layout = QVBoxLayout(mode_group)
        
        # Warning label for update all mode
        self.warning_label = QLabel(
            "⚠️ Warning: 'Update All' will completely overwrite the current contents of the destination folder!"
        )
        self.warning_label.setStyleSheet("QLabel { color: #ff6b6b; font-weight: bold; padding: 10px; }")
        self.warning_label.setWordWrap(True)
        mode_layout.addWidget(self.warning_label)
        
        # Radio buttons for update mode
        self.update_all_radio = QRadioButton("Rebuild Everything - Delete existing index and recreate from source")
        self.add_new_radio = QRadioButton("Add New Only - Add new headings, skip existing ones")
        self.add_new_radio.setChecked(True)  # Default to safer option
        
        mode_layout.addWidget(self.update_all_radio)
        mode_layout.addWidget(self.add_new_radio)
        
        # Checkbox for checking removed headings (only enabled for add_new mode)
        self.check_removed_checkbox = QCheckBox("Remove deleted headings - Remove indexed headings that aren't in the source")
        self.check_removed_checkbox.setChecked(True)  # Default to checked
        self.check_removed_checkbox.setToolTip(
            "When checked, headings that exist in the destination but not in the source will be deleted"
        )
        mode_layout.addWidget(self.check_removed_checkbox)
        
        # Connect radio buttons to update UI state
        self.update_all_radio.toggled.connect(self.on_mode_changed)
        self.add_new_radio.toggled.connect(self.on_mode_changed)
        
        doc_layout.addWidget(mode_group)
        
        # Input document selection
        input_group = QFrame()
        input_layout = QHBoxLayout(input_group)
        
        input_label = QLabel("Input Document:")
        self.input_field = QLineEdit()
        self.input_field.setReadOnly(True)
        self.input_field.setPlaceholderText("Select a Word document to process")
        
        input_button = QPushButton("Browse...")
        input_button.clicked.connect(self.browse_input_document)
        
        input_layout.addWidget(input_label)
        input_layout.addWidget(self.input_field, 1)
        input_layout.addWidget(input_button)
        
        doc_layout.addWidget(input_group)
        
        # Template document selection
        template_group = QFrame()
        template_layout = QHBoxLayout(template_group)
        
        template_label = QLabel("Template Document:")
        self.template_field = QLineEdit()
        self.template_field.setReadOnly(True)
        self.template_field.setPlaceholderText("Select a template document (optional)")
        
        template_button = QPushButton("Browse...")
        template_button.clicked.connect(self.browse_template_document)
        
        template_layout.addWidget(template_label)
        template_layout.addWidget(self.template_field, 1)
        template_layout.addWidget(template_button)
        
        doc_layout.addWidget(template_group)
        
        # Note: Heading level and hierarchy settings are read from metadata file
        
        # Output options
        output_group = QFrame()
        output_layout = QHBoxLayout(output_group)
        
        output_label = QLabel("Output Directory:")
        self.output_field = QLineEdit()
        self.output_field.setReadOnly(True)
        self.output_field.setPlaceholderText("Select output directory")
        
        output_button = QPushButton("Browse...")
        output_button.clicked.connect(self.browse_output_directory)
        
        output_layout.addWidget(output_label)
        output_layout.addWidget(self.output_field, 1)
        output_layout.addWidget(output_button)
        
        doc_layout.addWidget(output_group)
        
        # No additional options needed - hierarchy is auto-detected
        
        # Add to queue button
        self.add_button = QPushButton("Add to Queue")
        self.add_button.clicked.connect(self.add_to_queue)
        doc_layout.addWidget(self.add_button)
        
        doc_layout.addStretch()
        
        # Update All tab
        update_all_tab = QWidget()
        update_all_layout = QVBoxLayout(update_all_tab)
        
        # Update mode selection (same as main tab)
        update_all_mode_group = QGroupBox("Update Mode")
        update_all_mode_layout = QVBoxLayout(update_all_mode_group)
        
        # Warning label for update all mode
        self.update_all_warning_label = QLabel(
            "⚠️ Warning: 'Rebuild Everything' will completely overwrite the current contents of all source folders!"
        )
        self.update_all_warning_label.setStyleSheet("QLabel { color: #ff6b6b; font-weight: bold; padding: 10px; }")
        self.update_all_warning_label.setWordWrap(True)
        update_all_mode_layout.addWidget(self.update_all_warning_label)
        
        # Radio buttons for update mode (separate from main tab)
        self.update_all_rebuild_radio = QRadioButton("Rebuild Everything - Delete existing index and recreate from source")
        self.update_all_add_new_radio = QRadioButton("Add New Only - Add new headings, skip existing ones")
        self.update_all_add_new_radio.setChecked(True)  # Default to safer option
        
        update_all_mode_layout.addWidget(self.update_all_rebuild_radio)
        update_all_mode_layout.addWidget(self.update_all_add_new_radio)
        
        # Checkbox for checking removed headings (only enabled for add_new mode)
        self.update_all_check_removed_checkbox = QCheckBox("Remove deleted headings - Remove indexed headings that aren't in the source")
        self.update_all_check_removed_checkbox.setChecked(True)  # Default to checked
        self.update_all_check_removed_checkbox.setToolTip(
            "When checked, headings that exist in the destination but not in the source will be deleted"
        )
        update_all_mode_layout.addWidget(self.update_all_check_removed_checkbox)
        
        # Connect radio buttons to update UI state
        self.update_all_rebuild_radio.toggled.connect(self.on_update_all_mode_changed)
        self.update_all_add_new_radio.toggled.connect(self.on_update_all_mode_changed)
        
        update_all_layout.addWidget(update_all_mode_group)
        
        # Index folder selection
        index_folder_group = QFrame()
        index_folder_layout = QHBoxLayout(index_folder_group)
        
        index_folder_label = QLabel("Index Folder:")
        self.index_folder_field = QLineEdit()
        self.index_folder_field.setReadOnly(True)
        self.index_folder_field.setPlaceholderText("Select the index folder to update")
        
        index_folder_button = QPushButton("Browse...")
        index_folder_button.clicked.connect(self.browse_index_folder)
        
        index_folder_layout.addWidget(index_folder_label)
        index_folder_layout.addWidget(self.index_folder_field, 1)
        index_folder_layout.addWidget(index_folder_button)
        
        update_all_layout.addWidget(index_folder_group)
        
        # Template replacement section (initially hidden)
        self.template_replacement_group = QGroupBox("Template Replacement")
        template_replacement_layout = QVBoxLayout(self.template_replacement_group)
        
        self.template_warning_label = QLabel()
        self.template_warning_label.setWordWrap(True)
        self.template_warning_label.setStyleSheet("QLabel { color: #ff6b6b; padding: 5px; }")
        template_replacement_layout.addWidget(self.template_warning_label)
        
        # Template selection
        template_select_layout = QHBoxLayout()
        template_select_label = QLabel("Replacement Template:")
        self.replacement_template_field = QLineEdit()
        self.replacement_template_field.setReadOnly(True)
        self.replacement_template_field.setPlaceholderText("Select a template document to use for all updates")
        
        template_browse_button = QPushButton("Browse...")
        template_browse_button.clicked.connect(self.browse_replacement_template)
        
        template_select_layout.addWidget(template_select_label)
        template_select_layout.addWidget(self.replacement_template_field, 1)
        template_select_layout.addWidget(template_browse_button)
        
        template_replacement_layout.addLayout(template_select_layout)
        
        # Initially hide the template replacement section
        self.template_replacement_group.setVisible(False)
        update_all_layout.addWidget(self.template_replacement_group)
        
        # Source documents display
        sources_group = QGroupBox("Discovered Source Documents")
        sources_layout = QVBoxLayout(sources_group)
        
        self.sources_list = QListWidget()
        self.sources_list.setMinimumHeight(200)
        sources_layout.addWidget(self.sources_list)
        
        # Add all to queue button
        self.add_all_button = QPushButton("Add All to Queue")
        self.add_all_button.clicked.connect(self.add_all_to_queue)
        self.add_all_button.setEnabled(False)
        sources_layout.addWidget(self.add_all_button)
        
        update_all_layout.addWidget(sources_group)
        update_all_layout.addStretch()
        
        tab_widget.addTab(update_all_tab, "Update All")
        
        tab_widget.addTab(doc_selection_tab, "Update by Document")
        
        # Queue management tab
        queue_tab = QWidget()
        queue_layout = QVBoxLayout(queue_tab)
        
        # Queue list
        queue_label = QLabel("Processing Queue:")
        queue_layout.addWidget(queue_label)
        
        # Scroll area for queue items
        self.queue_scroll = QScrollArea()
        self.queue_scroll.setWidgetResizable(True)
        self.queue_container = QWidget()
        self.queue_container_layout = QVBoxLayout(self.queue_container)
        self.queue_container_layout.addStretch()
        self.queue_scroll.setWidget(self.queue_container)
        queue_layout.addWidget(self.queue_scroll)
        
        # Queue control buttons
        queue_controls = QHBoxLayout()
        
        self.clear_completed_button = QPushButton("Clear Completed")
        self.clear_completed_button.clicked.connect(self.clear_completed_items)
        queue_controls.addWidget(self.clear_completed_button)
        
        self.clear_queue_button = QPushButton("Clear All")
        self.clear_queue_button.clicked.connect(self.clear_queue)
        queue_controls.addWidget(self.clear_queue_button)
        
        queue_controls.addStretch()
        
        self.start_queue_button = QPushButton("Start Processing Queue")
        self.start_queue_button.clicked.connect(self.start_processing_queue)
        queue_controls.addWidget(self.start_queue_button)
        
        queue_layout.addLayout(queue_controls)
        
        tab_widget.addTab(queue_tab, "Queue")
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)
        
        # Status label
        self.status_label = QLabel("Ready")
        layout.addWidget(self.status_label)
        
        # Dialog buttons
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Close)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
        # Update UI state based on initial mode
        self.on_mode_changed()
        self.on_update_all_mode_changed()
    
    def on_mode_changed(self):
        """Handle update mode change."""
        if self.update_all_radio.isChecked():
            self.update_mode = "update_all"
            self.check_removed_checkbox.setEnabled(False)
            self.check_removed_checkbox.setChecked(False)
            self.warning_label.setVisible(True)
        else:
            self.update_mode = "add_new"
            self.check_removed_checkbox.setEnabled(True)
            self.warning_label.setVisible(False)
    
    def on_update_all_mode_changed(self):
        """Handle update all mode change."""
        if self.update_all_rebuild_radio.isChecked():
            self.update_all_check_removed_checkbox.setEnabled(False)
            self.update_all_check_removed_checkbox.setChecked(False)
            self.update_all_warning_label.setVisible(True)
        else:
            self.update_all_check_removed_checkbox.setEnabled(True)
            self.update_all_warning_label.setVisible(False)
    
    def browse_index_folder(self):
        """Open directory dialog to select index folder."""
        dir_path = QFileDialog.getExistingDirectory(
            self,
            "Select Index Folder",
            self.settings.value('last_index_dir', ''),
            QFileDialog.Option.ShowDirsOnly
        )
        
        if dir_path:
            self.index_folder_field.setText(dir_path)
            self.settings.setValue('last_index_dir', dir_path)
            self._discover_source_documents(Path(dir_path))
    
    def _discover_source_documents(self, index_folder):
        """Discover source documents in the index folder by scanning for metadata files recursively."""
        self.sources_list.clear()
        self.add_all_button.setEnabled(False)
        
        if not index_folder.exists():
            return
        
        discovered_sources = []
        self.missing_templates = set()  # Track unique missing template paths
        
        # Look for all metadata files recursively
        metadata_files = list(index_folder.rglob("*_metadata.json"))
        
        for metadata_file in metadata_files:
            try:
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    metadata = json.load(f)
                
                source_path = metadata.get('source_document_path')
                if source_path:
                    source_path = Path(source_path)
                    # Get the subfolder (parent directory of metadata file)
                    subfolder = metadata_file.parent
                    
                    if source_path.exists():
                        # Check if template exists
                        template_path = metadata.get('template_path')
                        template_exists = template_path and Path(template_path).exists()
                        
                        if not template_exists and template_path:
                            self.missing_templates.add(template_path)
                        
                        discovered_sources.append({
                            'source_path': source_path,
                            'metadata_file': metadata_file,
                            'subfolder': subfolder,
                            'metadata': metadata,
                            'template_exists': template_exists
                        })
                        
                        # Add to list widget with relative path for better visibility
                        relative_path = subfolder.relative_to(index_folder)
                        template_warning = " ⚠️ (missing template)" if not template_exists else ""
                        item_text = f"{source_path.name} → {relative_path}{template_warning}"
                        self.sources_list.addItem(item_text)
                    else:
                        # Source file doesn't exist - add error item
                        error_text = f"❌ {source_path.name} (FILE NOT FOUND: {source_path})"
                        error_item = QListWidgetItem(error_text)
                        error_item.setForeground(QColor('red'))
                        self.sources_list.addItem(error_item)
                
            except Exception as e:
                print(f"Error reading metadata file {metadata_file}: {e}")
        
        # Store discovered sources for later use
        self.discovered_sources = discovered_sources
        
        # Check for nested indexes
        self.has_nested_indexes = self._detect_nested_indexes(discovered_sources)
        if self.has_nested_indexes:
            print("WARNING: Nested indexes detected!")
        
        # Show/hide template replacement section based on missing templates
        if self.missing_templates:
            # Show template replacement section
            self.template_replacement_group.setVisible(True)
            template_list = "\n".join(f"• {path}" for path in sorted(self.missing_templates))
            self.template_warning_label.setText(
                f"⚠️ The following template files were not found:\n{template_list}\n\n"
                "Please select a replacement template to use for all updates."
            )
            # Disable add all button until replacement template is selected
            self.add_all_button.setEnabled(False)
        else:
            # Hide template replacement section
            self.template_replacement_group.setVisible(False)
            self.replacement_template_path = None
            self.replacement_template_field.clear()
            # Enable add all button if we found valid sources
            if discovered_sources:
                self.add_all_button.setEnabled(True)
        
        # Update status message
        if discovered_sources:
            print(f"DISCOVERED: {len(discovered_sources)} source documents in index folder")
        else:
            self.sources_list.addItem("No valid source documents found in this index folder")
    
    def _detect_nested_indexes(self, discovered_sources):
        """Detect if there are nested indexes (one index inside another)."""
        if len(discovered_sources) < 2:
            return False
        
        # Check if any subfolder is a parent/child of another
        subfolders = [source['subfolder'] for source in discovered_sources]
        
        for i, folder1 in enumerate(subfolders):
            for j, folder2 in enumerate(subfolders):
                if i != j:
                    # Check if folder1 is inside folder2 or vice versa
                    try:
                        folder1.relative_to(folder2)
                        return True  # folder1 is inside folder2
                    except ValueError:
                        pass
                    
                    try:
                        folder2.relative_to(folder1)
                        return True  # folder2 is inside folder1
                    except ValueError:
                        pass
        
        return False
    
    def browse_replacement_template(self):
        """Open file dialog to select replacement template document."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Replacement Template Document",
            self.settings.value('last_template_dir', ''),
            "Word Documents (*.docx)"
        )
        
        if file_path:
            self.replacement_template_path = Path(file_path)
            self.replacement_template_field.setText(str(self.replacement_template_path))
            self.settings.setValue('last_template_dir', str(self.replacement_template_path.parent))
            
            # Enable add all button if we have discovered sources
            if hasattr(self, 'discovered_sources') and self.discovered_sources:
                self.add_all_button.setEnabled(True)
    
    def add_all_to_queue(self):
        """Add all discovered source documents to the queue."""
        if not hasattr(self, 'discovered_sources'):
            return
        
        # Get update mode from Update All tab
        update_mode = "update_all" if self.update_all_rebuild_radio.isChecked() else "add_new"
        check_removed = self.update_all_check_removed_checkbox.isChecked()
        
        # Check for nested indexes with problematic settings
        if hasattr(self, 'has_nested_indexes') and self.has_nested_indexes:
            if update_mode == "update_all" or check_removed:
                reply = QMessageBox.warning(
                    self,
                    "Nested Indexes Detected",
                    "This index folder contains nested indexes (indexes within indexes).\n\n"
                    "Using 'Rebuild Everything' or 'Remove deleted headings' with nested indexes "
                    "will cause higher-level indexes to overwrite lower-level ones.\n\n"
                    "To update nested indexes safely, you should:\n"
                    "• Select 'Add New Only' mode\n"
                    "• Uncheck 'Remove deleted headings'\n\n"
                    "Do you want to continue with the current settings anyway?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No
                )
                
                if reply != QMessageBox.StandardButton.Yes:
                    return
        
        added_count = 0
        for source_info in self.discovered_sources:
            try:
                metadata = source_info['metadata']
                
                # Determine which template to use
                original_template_path = Path(metadata.get('template_path', ''))
                
                if self.replacement_template_path:
                    # Use replacement template for all
                    template_to_use = self.replacement_template_path
                else:
                    # Use original template from metadata
                    template_to_use = original_template_path
                    
                    # Skip if template doesn't exist and no replacement provided
                    if not template_to_use.exists():
                        print(f"Skipping {source_info['source_path'].name}: Template not found and no replacement provided")
                        continue
                
                # Create queue item from metadata
                queue_item = SplitQueueItem(
                    input_path=source_info['source_path'],
                    template_path=template_to_use,
                    output_dir=source_info['subfolder'],
                    heading_level=metadata.get('heading_level', 3),
                    preserve_hierarchy=metadata.get('preserve_hierarchy', False),
                    create_zip=False
                )
                
                # Store original template path if we're using a replacement
                if self.replacement_template_path and template_to_use != original_template_path:
                    queue_item.original_template_path = original_template_path
                
                # Add update-specific attributes
                queue_item.update_mode = update_mode
                queue_item.check_removed = check_removed
                
                # Add to queue
                self.queue_items.append(queue_item)
                
                # Create widget for queue item
                item_widget = QueueItemWidget(queue_item, len(self.queue_items) - 1)
                item_widget.destination_changed.connect(self.on_destination_changed)
                item_widget.remove_requested.connect(self.remove_queue_item)
                
                self.queue_widgets.append(item_widget)
                
                # Add to UI (before the stretch)
                self.queue_container_layout.insertWidget(
                    self.queue_container_layout.count() - 1,
                    item_widget
                )
                
                added_count += 1
                
            except Exception as e:
                print(f"Error adding {source_info['source_path']} to queue: {e}")
        
        self.update_status(f"Added {added_count} source documents to queue")
        
        # Switch to Queue tab to show the results
        self.parent().findChild(QTabWidget).setCurrentIndex(2)  # Queue tab is index 2
    
    def browse_input_document(self):
        """Open file dialog to select input document."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Input Document",
            self.settings.value('last_input_dir', ''),
            "Word Documents (*.docx)"
        )
        
        if file_path:
            self.input_path = Path(file_path)
            self.input_field.setText(str(self.input_path))
            self.settings.setValue('last_input_dir', str(self.input_path.parent))
    
    def browse_template_document(self):
        """Open file dialog to select template document."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Template Document",
            self.settings.value('last_template_dir', ''),
            "Word Documents (*.docx)"
        )
        
        if file_path:
            self.template_path = Path(file_path)
            self.template_field.setText(str(self.template_path))
            self.settings.setValue('last_template_dir', str(self.template_path.parent))
    
    def browse_output_directory(self):
        """Open directory dialog to select output directory."""
        dir_path = QFileDialog.getExistingDirectory(
            self,
            "Select Output Directory",
            self.settings.value('last_output_dir', ''),
            QFileDialog.Option.ShowDirsOnly
        )
        
        if dir_path:
            self.output_dir = Path(dir_path)
            self.output_field.setText(str(self.output_dir))
            self.settings.setValue('last_output_dir', str(self.output_dir))
    
    def add_to_queue(self):
        """Add current configuration to processing queue."""
        # Validate inputs
        if not self.input_path:
            QMessageBox.warning(self, "Missing Input", "Please select an input document.")
            return
        
        if not self.template_path:
            QMessageBox.warning(self, "Missing Template", "Please select a template document.")
            return
        
        if not self.output_dir:
            QMessageBox.warning(self, "Missing Output", "Please select an output directory.")
            return
        
        # Validate that output directory has proper metadata structure
        if not self._validate_output_directory():
            return
        
        # Read settings from metadata file
        heading_level, preserve_hierarchy = self._read_metadata_settings()
        
        # Create queue item with update-specific settings
        queue_item = SplitQueueItem(
            input_path=self.input_path,
            template_path=self.template_path,
            output_dir=self.output_dir,
            heading_level=heading_level,
            preserve_hierarchy=preserve_hierarchy,
            create_zip=False  # Always False for updates
        )
        
        # Add update-specific attributes
        queue_item.update_mode = self.update_mode
        queue_item.check_removed = self.check_removed_checkbox.isChecked()
        
        # Add to queue
        self.queue_items.append(queue_item)
        
        # Create widget for queue item
        item_widget = QueueItemWidget(queue_item, len(self.queue_items) - 1)
        item_widget.destination_changed.connect(self.on_destination_changed)
        item_widget.remove_requested.connect(self.remove_queue_item)
        
        self.queue_widgets.append(item_widget)
        
        # Add to UI (before the stretch)
        self.queue_container_layout.insertWidget(
            self.queue_container_layout.count() - 1,
            item_widget
        )
        
        # Update status
        self.update_status(f"Added {queue_item.display_name} to queue")
        
        # Clear inputs for next item
        self.clear_inputs()
    
    def _read_metadata_settings(self):
        """
        Read heading level and preserve hierarchy settings from metadata file.
        Returns (heading_level, preserve_hierarchy) tuple.
        """
        if not self.output_dir or not self.output_dir.exists():
            return 3, False  # Default values
        
        # Find metadata file
        metadata_files = list(self.output_dir.glob("*_metadata.json"))
        if not metadata_files:
            print("No metadata file found, using defaults")
            return 3, False
        
        try:
            with open(metadata_files[0], 'r', encoding='utf-8') as f:
                metadata = json.load(f)
            
            heading_level = metadata.get('heading_level', 3)
            preserve_hierarchy = metadata.get('preserve_hierarchy', False)
            
            print(f"READ METADATA: heading_level={heading_level}, preserve_hierarchy={preserve_hierarchy}")
            return heading_level, preserve_hierarchy
            
        except Exception as e:
            print(f"Error reading metadata file: {e}")
            return 3, False  # Default values
    
    def _validate_output_directory(self):
        """
        Validate that the output directory has metadata files in the root.
        For Update Document mode, we expect one metadata file in the root directory.
        """
        if not self.output_dir or not self.output_dir.exists():
            QMessageBox.critical(
                self,
                "Invalid Output Directory",
                "The selected output directory does not exist."
            )
            return False
        
        # Check for metadata files in the root directory
        metadata_files = list(self.output_dir.glob("*_metadata.json"))
        
        if not metadata_files:
            QMessageBox.critical(
                self,
                "No Metadata Files Found",
                "This directory does not contain any metadata files (*_metadata.json).\n\n"
                "The Update Document feature requires a folder with a metadata file. "
                "Please re-create the index folder using 'Add Files to Index'.",
                QMessageBox.StandardButton.Ok
            )
            return False
        
        print(f"FOUND {len(metadata_files)} metadata files in root directory")
        return True
    
    def clear_inputs(self):
        """Clear input fields after adding to queue."""
        self.input_path = None
        self.input_field.clear()
        # Don't clear template and output as they're often reused
    
    def clear_queue(self):
        """Clear all items from the queue."""
        if self.is_processing:
            QMessageBox.warning(self, "Processing Active", 
                              "Cannot clear queue while processing is active.")
            return
        
        # Clear UI
        for widget in self.queue_widgets:
            widget.deleteLater()
        
        # Clear data
        self.queue_items.clear()
        self.queue_widgets.clear()
        
        self.update_status("Queue cleared")
    
    def clear_completed_items(self):
        """Remove completed items from the queue."""
        if self.is_processing:
            QMessageBox.warning(self, "Processing Active", 
                              "Cannot modify queue while processing is active.")
            return
        
        # Find completed items
        completed_indexes = []
        for i, item in enumerate(self.queue_items):
            if item.status == "completed":
                completed_indexes.append(i)
        
        # Remove in reverse order to maintain indexes
        for i in reversed(completed_indexes):
            self.queue_widgets[i].deleteLater()
            del self.queue_widgets[i]
            del self.queue_items[i]
        
        # Update remaining widget indexes
        for i, widget in enumerate(self.queue_widgets):
            widget.index = i
        
        if completed_indexes:
            self.update_status(f"Removed {len(completed_indexes)} completed items")
    
    def remove_queue_item(self, index):
        """Remove a specific item from the queue."""
        if self.is_processing:
            QMessageBox.warning(self, "Processing Active", 
                              "Cannot modify queue while processing is active.")
            return
        
        if 0 <= index < len(self.queue_items):
            # Remove widget
            self.queue_widgets[index].deleteLater()
            del self.queue_widgets[index]
            del self.queue_items[index]
            
            # Update remaining widget indexes
            for i, widget in enumerate(self.queue_widgets):
                widget.index = i
            
            self.update_status(f"Removed item #{index+1}")
    
    def on_destination_changed(self, index, new_path):
        """Handle destination change for a queue item."""
        if 0 <= index < len(self.queue_items):
            self.queue_items[index].output_dir = Path(new_path)
            self.update_status(f"Changed destination for item #{index+1}")
    
    def start_processing_queue(self):
        """Start or resume processing the queue with update-specific logic."""
        if self.is_processing:
            # Cancel processing
            self.cancel_processing()
            return
        
        # Find first non-completed item
        start_index = 0
        for i, item in enumerate(self.queue_items):
            if item.status != "completed":
                start_index = i
                break
        else:
            # All items completed
            QMessageBox.information(self, "Queue Complete", 
                                  "All items in the queue have been processed.")
            return
        
        # Confirm update all operations
        update_all_items = [item for item in self.queue_items if hasattr(item, 'update_mode') and item.update_mode == "update_all"]
        if update_all_items:
            msg = f"You have {len(update_all_items)} 'Update All' operations in the queue.\n\n"
            msg += "These will COMPLETELY DELETE and rebuild the contents of their destination folders.\n\n"
            msg += "Are you sure you want to proceed?"
            
            reply = QMessageBox.warning(
                self,
                "Confirm Update All Operations",
                msg,
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply != QMessageBox.StandardButton.Yes:
                return
        
        self.is_processing = True
        self.start_queue_button.setText("Cancel Processing")
        self.progress_bar.setVisible(True)
        
        # Create worker thread with update support
        self.worker_thread = QThread()
        self.worker = UpdateIndexWorker(self.queue_items, start_index)
        self.worker.moveToThread(self.worker_thread)
        
        # Connect signals
        self.worker_thread.started.connect(self.worker.process_queue)
        self.worker.status_changed.connect(self.on_worker_status_changed)
        self.worker.progress_updated.connect(self.on_worker_progress_updated)
        self.worker.item_completed.connect(self.on_worker_item_completed)
        self.worker.item_error.connect(self.on_worker_item_error)
        self.worker.all_completed.connect(self.on_processing_complete)
        
        # Start processing
        self.worker_thread.start()
        self.update_status(f"Started processing queue at item #{start_index+1}")
    
    def cancel_processing(self):
        """Cancel the current processing operation."""
        if self.worker:
            self.worker.cancel()
            self.update_status("Canceling operation...")
    
    def on_worker_status_changed(self, index, message):
        """Handle status change from worker thread."""
        if 0 <= index < len(self.queue_widgets):
            self.queue_widgets[index].update_status_message(message)
    
    def on_worker_progress_updated(self, index, percent):
        """Handle progress update from worker thread."""
        if 0 <= index < len(self.queue_widgets):
            self.queue_widgets[index].update_progress(percent)
        self.progress_bar.setValue(percent)
    
    def on_worker_item_completed(self, index, result_path, status):
        """Handle item completion from worker thread."""
        if 0 <= index < len(self.queue_items):
            self.queue_items[index].status = "completed"
            self.queue_items[index].result_path = result_path
            
            if 0 <= index < len(self.queue_widgets):
                self.queue_widgets[index].set_completed(str(result_path))
            
            self.update_status(f"Completed processing {self.queue_items[index].display_name}")
    
    def on_worker_item_error(self, index, error_message):
        """Handle item error from worker thread."""
        if 0 <= index < len(self.queue_items):
            self.queue_items[index].status = "error"
            
            if 0 <= index < len(self.queue_widgets):
                self.queue_widgets[index].set_error(error_message)
            
            self.update_status(f"Error processing {self.queue_items[index].display_name}: {error_message}")
    
    def on_processing_complete(self):
        """Handle completion of all queue processing."""
        self.is_processing = False
        self.start_queue_button.setText("Start Processing Queue")
        self.progress_bar.setVisible(False)
        self.update_status("Queue processing complete")
        
        # Refresh the main window's index if needed
        if self.parent() and hasattr(self.parent(), 'index_documents'):
            self.parent().index_documents()
        
        # Clean up worker
        if self.worker_thread:
            self.worker_thread.quit()
            self.worker_thread.wait()
            self.worker_thread.deleteLater()
            self.worker_thread = None
        
        if self.worker:
            self.worker.deleteLater()
            self.worker = None
    
    def update_status(self, message):
        """Update the status label."""
        self.status_label.setText(message)
    
    def load_settings(self):
        """Load saved settings."""
        # Load template path if saved
        template_path = self.settings.value('last_template_path', '')
        if template_path and Path(template_path).exists():
            self.template_path = Path(template_path)
            self.template_field.setText(str(self.template_path))
        
        # Note: Heading level is now read from metadata file
    
    def save_settings(self):
        """Save current settings."""
        if self.template_path:
            self.settings.setValue('last_template_path', str(self.template_path))
        
        # Note: Heading level is now read from metadata file
    
    def reject(self):
        """Handle dialog rejection."""
        if self.is_processing:
            reply = QMessageBox.question(
                self,
                "Processing Active",
                "Processing is still active. Do you want to cancel and close?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                self.cancel_processing()
                # Wait a moment for cancellation
                QTimer.singleShot(100, self.force_close)
            return
        
        self.save_settings()
        super().reject()
    
    def force_close(self):
        """Force close after cancellation."""
        if self.worker:
            self.worker.is_cancelled = True
        if self.worker_thread and self.worker_thread.isRunning():
            self.worker_thread.terminate()
            self.worker_thread.wait()
        
        self.save_settings()
        self.done(0)


class UpdateIndexWorker(DocxSplitterWorker):
    """
    Enhanced worker class for update operations that supports:
    - Update All mode (delete and rebuild)
    - Add New Only mode (skip existing files)
    - Check for removed headings option
    """
    
    def process_queue(self):
        """Process the queue with update-specific logic."""
        self.is_running = True
        
        for index in range(self.current_index, len(self.queue_items)):
            if self.is_cancelled:
                break
            
            self.current_index = index
            queue_item = self.queue_items[index]
            
            try:
                # Update status
                queue_item.status = "processing"
                self.status_changed.emit(index, "Processing...")
                
                # Get update mode and settings
                update_mode = getattr(queue_item, 'update_mode', 'add_new')
                check_removed = getattr(queue_item, 'check_removed', False)
                
                # Process based on update mode
                if update_mode == "update_all":
                    self._process_update_all(queue_item, index)
                else:
                    self._process_add_new_only(queue_item, index, check_removed)
                
            except Exception as e:
                error_msg = str(e)
                print(f"Error processing item {index}: {error_msg}")
                import traceback
                traceback.print_exc()
                self.item_error.emit(index, error_msg)
        
        self.is_running = False
        self.all_completed.emit()
    
    def _process_update_all(self, queue_item, index):
        """Process update all mode - delete EVERYTHING and rebuild from scratch."""
        try:
            # Step 1: Delete ALL files and directories in the output directory
            self.status_changed.emit(index, "Deleting all existing content...")
            
            if queue_item.output_dir.exists():
                # Get all files and directories
                all_items = list(queue_item.output_dir.rglob("*"))
                all_files = [item for item in all_items if item.is_file()]
                all_dirs = [item for item in all_items if item.is_dir()]
                
                total_items = len(all_files)
                print(f"UPDATE ALL: Deleting ALL {total_items} files and {len(all_dirs)} directories")
                
                # Delete all files first
                for i, file in enumerate(all_files):
                    if self.is_cancelled:
                        return
                    
                    try:
                        file.unlink()
                        print(f"DELETED: {file.relative_to(queue_item.output_dir)}")
                    except Exception as e:
                        print(f"ERROR DELETING: {file}: {e}")
                    
                    # Update progress (files deletion takes 20% of total progress)
                    percent = int((i + 1) / total_items * 20) if total_items > 0 else 20
                    self.progress_updated.emit(index, percent)
                
                # Delete all directories (deepest first)
                for directory in sorted(all_dirs, key=lambda d: len(d.parts), reverse=True):
                    if self.is_cancelled:
                        return
                    
                    try:
                        if directory.exists():
                            directory.rmdir()
                            print(f"DELETED DIRECTORY: {directory.relative_to(queue_item.output_dir)}")
                    except Exception as e:
                        # Directory might not be empty, which is fine
                        pass
            
            # Step 2: Rebuild from scratch using standard processing
            self.status_changed.emit(index, "Rebuilding index from source...")
            
            # Create splitter
            splitter = DocxSplitter(
                input_path=queue_item.input_path,
                template_path=queue_item.template_path,
                status_callback=lambda msg: self.status_changed.emit(index, msg),
                progress_callback=lambda percent: self.progress_updated.emit(
                    index, 20 + int(percent * 80 / 100)  # Use remaining 80% for rebuild
                )
            )
            
            # Parse sections
            splitter.parse_sections(queue_item.heading_level)
            
            if not splitter.sections:
                raise ValueError(f"No sections found at heading level {queue_item.heading_level}")
            
            print(f"UPDATE ALL: Rebuilding {len(splitter.sections)} sections from scratch")
            
            # Process document using standard method (no skip-existing logic needed)
            # For update all, we need to output to the parent directory so the new
            # source subfolder structure can be created properly
            parent_dir = queue_item.output_dir.parent
            result = splitter.process_document(
                output_dir=parent_dir,
                target_level=queue_item.heading_level,
                create_zip=False,  # Always False for updates
                preserve_hierarchy=queue_item.preserve_hierarchy
            )
            
            if result:
                self.item_completed.emit(index, result, "completed")
            else:
                raise ValueError("Document processing failed")
            
        except Exception as e:
            raise Exception(f"Update all failed: {str(e)}")
    
    def _process_add_new_only(self, queue_item, index, check_removed):
        """Process add new only mode - skip existing files."""
        try:
            # Check if we need to update metadata with new template path
            needs_metadata_update = False
            if hasattr(queue_item, 'original_template_path'):
                # This is set when we use a replacement template
                needs_metadata_update = queue_item.template_path != queue_item.original_template_path
            
            # Create splitter with skip-existing functionality
            splitter = DocxSplitter(
                input_path=queue_item.input_path,
                template_path=queue_item.template_path,
                status_callback=lambda msg: self._status_callback_with_index(index, msg),
                progress_callback=lambda percent: self._progress_callback_with_offset(index, percent, 0)
            )
            
            # Parse sections
            self.status_changed.emit(index, f"Parsing sections at level {queue_item.heading_level}...")
            splitter.parse_sections(queue_item.heading_level)
            
            if not splitter.sections:
                raise ValueError(f"No sections found at heading level {queue_item.heading_level}")
            
            # Step 1: Handle file movement if preserve_hierarchy is enabled
            if queue_item.preserve_hierarchy and queue_item.output_dir.exists():
                self._reorganize_files_for_hierarchy(queue_item, index, splitter)
            
            # Get list of existing files if checking for removed
            existing_files = set()
            if check_removed and queue_item.output_dir.exists():
                # Get all docx files in the output directory
                for file in queue_item.output_dir.glob("**/*.docx"):
                    existing_files.add(file.name)
            
            # Process document with skip-existing mode
            result = splitter.process_document_update(
                output_dir=queue_item.output_dir,
                target_level=queue_item.heading_level,
                preserve_hierarchy=queue_item.preserve_hierarchy,
                skip_existing=True,
                progress_callback=lambda current, total, action: self._update_progress_callback(index, current, total, action)
            )
            
            if result:
                # Check for removed headings if requested
                if check_removed and existing_files:
                    self._check_removed_headings(queue_item, index, splitter, existing_files)
                
                # Always update metadata timestamp, and template path if needed
                self._update_metadata_after_update(queue_item, needs_metadata_update)
                
                self.item_completed.emit(index, result, "completed")
            else:
                raise ValueError("Document processing failed")
            
        except Exception as e:
            raise Exception(f"Add new only failed: {str(e)}")
    
    def _update_metadata_after_update(self, queue_item, update_template_path=False):
        """Update metadata file after an update operation."""
        try:
            # Find metadata file in output directory
            metadata_files = list(queue_item.output_dir.glob("*_metadata.json"))
            if not metadata_files:
                print(f"WARNING: No metadata file found to update in {queue_item.output_dir}")
                return
            
            for metadata_file in metadata_files:
                # Read existing metadata
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    metadata = json.load(f)
                
                # Always update timestamp
                metadata['created_timestamp'] = datetime.now().isoformat()
                
                # Update template path if needed
                if update_template_path:
                    old_template = metadata.get('template_path', 'None')
                    metadata['template_path'] = str(queue_item.template_path.absolute())
                    print(f"UPDATED METADATA: {metadata_file.name} - template path changed from {old_template} to {queue_item.template_path}")
                else:
                    print(f"UPDATED METADATA: {metadata_file.name} - timestamp updated")
                
                # Write updated metadata
                with open(metadata_file, 'w', encoding='utf-8') as f:
                    json.dump(metadata, f, indent=2)
                
        except Exception as e:
            print(f"Error updating metadata file: {e}")
            # Don't fail the whole operation if metadata update fails
    
    def _reorganize_files_for_hierarchy(self, queue_item, index, splitter):
        """
        Reorganize existing files to match new folder structure based on updated hierarchy.
        This handles cases where the document structure has changed.
        """
        self.status_changed.emit(index, "Reorganizing files for updated hierarchy...")
        
        # Map existing files to their expected new locations
        files_to_move = []
        
        # Get all existing docx files
        existing_files = list(queue_item.output_dir.glob("**/*.docx"))
        
        for existing_file in existing_files:
            # Try to match existing file to a section
            for section in splitter.sections:
                # The filename is simply the safe_title
                filename = section.safe_title
                
                # Check if this is the same file (by filename without path)
                if existing_file.name == f"{filename}.docx":
                    # Determine new path
                    if section.parent is not None:
                        folder_components = section.get_path_components()
                        new_dir = queue_item.output_dir
                        
                        for component in folder_components:
                            new_dir = new_dir / component
                        
                        new_path = new_dir / existing_file.name
                    else:
                        new_path = queue_item.output_dir / existing_file.name
                    
                    # Check if file needs to be moved
                    if existing_file != new_path:
                        files_to_move.append((existing_file, new_path))
                    break
        
        # Move files to new locations
        if files_to_move:
            self.status_changed.emit(index, f"Moving {len(files_to_move)} files to new locations...")
            print(f"REORGANIZING: Moving {len(files_to_move)} files for updated hierarchy")
            
            for old_path, new_path in files_to_move:
                try:
                    # Create target directory if needed
                    new_path.parent.mkdir(parents=True, exist_ok=True)
                    
                    # Move the file
                    old_path.rename(new_path)
                    print(f"MOVED: {old_path.name} -> {new_path}")
                    
                    # Move associated metadata file if it exists
                    old_meta = old_path.with_suffix(old_path.suffix + '.meta.json')
                    if old_meta.exists():
                        new_meta = new_path.with_suffix(new_path.suffix + '.meta.json')
                        old_meta.rename(new_meta)
                        print(f"MOVED METADATA: {old_meta.name} -> {new_meta}")
                    
                except Exception as e:
                    print(f"ERROR MOVING: {old_path} to {new_path}: {e}")
            
            # Clean up empty directories
            self._cleanup_empty_directories(queue_item.output_dir)
    
    def _cleanup_empty_directories(self, root_dir):
        """Remove empty subdirectories."""
        for dirpath in sorted(root_dir.rglob("*"), reverse=True):
            if dirpath.is_dir():
                try:
                    if not any(dirpath.iterdir()):
                        dirpath.rmdir()
                except Exception:
                    pass
    
    def _cleanup_directories_thoroughly(self, root_dir, directories_to_check):
        """
        Thoroughly clean up directories that may have become empty after file removal.
        Works bottom-up to ensure all empty parent directories are removed.
        """
        # Add all parent directories up to the root to the check list
        all_dirs_to_check = set(directories_to_check)
        for directory in directories_to_check:
            current = directory
            while current != root_dir and current.parent != current:
                current = current.parent
                if current != root_dir:
                    all_dirs_to_check.add(current)
        
        # Sort in reverse order (deepest first) to remove from bottom up
        sorted_dirs = sorted(all_dirs_to_check, key=lambda d: len(d.parts), reverse=True)
        
        for directory in sorted_dirs:
            try:
                if directory.exists() and directory.is_dir():
                    # Check if directory is empty (no files or subdirectories)
                    contents = list(directory.iterdir())
                    if not contents:
                        directory.rmdir()
                        print(f"REMOVED EMPTY DIRECTORY: {directory.relative_to(root_dir)}")
            except Exception as e:
                # Directory might not be empty or might have permission issues
                # This is normal, so we don't print errors unless it's unexpected
                pass
    
    def _check_removed_headings(self, queue_item, index, splitter, existing_files):
        """Check for and remove headings that no longer exist in the source."""
        self.status_changed.emit(index, "Checking for removed headings...")
        
        # Get list of current section filenames
        current_filenames = set()
        for section in splitter.sections:
            # The filename is simply the safe_title
            filename = section.safe_title
            current_filenames.add(filename + ".docx")
        
        # Find files that exist but are no longer in the source
        removed_files = existing_files - current_filenames
        
        if removed_files:
            self.status_changed.emit(index, f"Removing {len(removed_files)} obsolete files...")
            print(f"REMOVING OBSOLETE: {len(removed_files)} files no longer in source")
            
            # Keep track of directories that might become empty
            directories_to_check = set()
            
            for filename in removed_files:
                # Find the file in the output directory
                for file in queue_item.output_dir.rglob(filename):
                    try:
                        # Remember the parent directory for cleanup check
                        if file.parent != queue_item.output_dir:
                            directories_to_check.add(file.parent)
                        
                        # Delete the file
                        file.unlink()
                        print(f"REMOVED: {filename} (no longer in source)")
                        
                        # Delete associated metadata files
                        # Check for both .docx.meta.json and .meta.json formats
                        meta_file1 = file.with_suffix(file.suffix + '.meta.json')
                        meta_file2 = file.with_suffix('.meta.json')
                        
                        for meta_file in [meta_file1, meta_file2]:
                            if meta_file.exists():
                                meta_file.unlink()
                                print(f"REMOVED METADATA: {meta_file.name}")
                        
                        # Also look for any other metadata files that might be related
                        # (in case there are other naming conventions)
                        stem = file.stem
                        for meta_file in file.parent.glob(f"{stem}*.meta.json"):
                            try:
                                meta_file.unlink()
                                print(f"REMOVED METADATA: {meta_file.name}")
                            except Exception as e:
                                print(f"ERROR REMOVING METADATA: {meta_file}: {e}")
                        
                    except Exception as e:
                        print(f"ERROR REMOVING: {file}: {e}")
            
            # Clean up empty directories after removing files
            if directories_to_check:
                print(f"CLEANUP: Checking {len(directories_to_check)} directories for cleanup")
                self._cleanup_directories_thoroughly(queue_item.output_dir, directories_to_check)
    
    def _status_callback_with_index(self, index, message):
        """Status callback that includes the index."""
        self.status_changed.emit(index, message)
    
    def _progress_callback_with_offset(self, index, percent, offset):
        """Progress callback with offset for multi-step operations."""
        adjusted_percent = offset + int(percent * (100 - offset) / 100)
        self.progress_updated.emit(index, adjusted_percent)
    
    def _update_progress_callback(self, index, current, total, action):
        """Enhanced progress callback that shows what action is being taken."""
        percent = int(current / total * 100) if total > 0 else 0
        self.progress_updated.emit(index, percent)
        
        # Update status to show current action
        section_name = self.queue_items[index].input_path.stem
        if current <= total:
            self.status_changed.emit(index, f"Processing {current}/{total}: {action}")
    
    def _process_document(self, queue_item, index, progress_offset=0):
        """Process document with progress reporting."""
        try:
            # Create splitter
            splitter = DocxSplitter(
                input_path=queue_item.input_path,
                template_path=queue_item.template_path,
                status_callback=lambda msg: self.status_changed.emit(index, msg),
                progress_callback=lambda percent: self.progress_updated.emit(
                    index, progress_offset + int(percent * (100 - progress_offset) / 100)
                )
            )
            
            self.current_splitter = splitter
            
            # Parse sections
            splitter.parse_sections(queue_item.heading_level)
            
            if not splitter.sections:
                raise ValueError(f"No sections found at heading level {queue_item.heading_level}")
            
            # Process document
            result = splitter.process_document(
                output_dir=queue_item.output_dir,
                target_level=queue_item.heading_level,
                create_zip=False,  # Always False for updates
                preserve_hierarchy=queue_item.preserve_hierarchy
            )
            
            if result:
                self.item_completed.emit(index, result, "completed")
            else:
                raise ValueError("Document processing failed")
            
        except Exception as e:
            raise
        finally:
            self.current_splitter = None


class PrefixManager:
    """
    Manages search prefixes and their associated folder mappings.
    Handles validation, storage, and retrieval of prefix configurations.
    """
    
    def __init__(self, settings: QSettings):
        self.settings = settings
        self.prefix_configs: Dict[str, Set[str]] = {}
        self.excluded_folders: Set[str] = set()
        self._load_prefixes()
    
    def _is_valid_prefix(self, prefix: str) -> bool:
        """
        Validate a prefix string.
        Only allows alphanumeric characters (no spaces or special characters).
        """
        return bool(re.match(r'^[a-zA-Z0-9]+$', prefix))
    
    def _load_prefixes(self) -> None:
        """Load prefix configurations from settings."""
        self.prefix_configs.clear()
        size = self.settings.beginReadArray("prefixes")
        
        for i in range(size):
            self.settings.setArrayIndex(i)
            prefix = self.settings.value("prefix", "")
            folders = self.settings.value("folders", set())
            
            # Convert folders to set if it's not already
            if isinstance(folders, str):
                folders = {folders}
            elif isinstance(folders, list):
                folders = set(folders)
                
            if self._is_valid_prefix(prefix):
                self.prefix_configs[prefix] = folders
                
        self.settings.endArray()

        excluded_folders = self.settings.value("excluded_folders", [])
        if excluded_folders:
            if isinstance(excluded_folders, str):
                self.excluded_folders = {excluded_folders}
            else:
                self.excluded_folders = set(excluded_folders)

    def _save_prefixes(self) -> None:
        """Save prefix configurations to settings."""
        self.settings.beginWriteArray("prefixes")
        
        for i, (prefix, folders) in enumerate(self.prefix_configs.items()):
            self.settings.setArrayIndex(i)
            self.settings.setValue("prefix", prefix)
            self.settings.setValue("folders", list(folders))
            
        self.settings.endArray()

        self.settings.setValue("excluded_folders", list(self.excluded_folders))
    
    def add_prefix_folder(self, prefix: str, folder: str) -> bool:
        """
        Add a folder to a prefix's configuration.
        Creates new prefix if it doesn't exist.
        
        Args:
            prefix: The prefix to configure
            folder: Path to the folder to associate with the prefix
            
        Returns:
            bool: True if successful, False if prefix is invalid
        """
        if not self._is_valid_prefix(prefix):
            return False
            
        if prefix not in self.prefix_configs:
            self.prefix_configs[prefix] = set()
            
        self.prefix_configs[prefix].add(folder)
        self._save_prefixes()
        return True
    
    def remove_prefix_folder(self, prefix: str, folder: str) -> bool:
        """
        Remove a folder from a prefix's configuration.
        
        Args:
            prefix: The prefix to modify
            folder: Path to remove from the prefix
            
        Returns:
            bool: True if successful, False if prefix doesn't exist
        """
        if prefix not in self.prefix_configs:
            return False
            
        self.prefix_configs[prefix].discard(folder)
        
        # Remove prefix entirely if no folders remain
        if not self.prefix_configs[prefix]:
            del self.prefix_configs[prefix]
            
        self._save_prefixes()
        return True
    
    def get_folders_for_prefix(self, prefix: str) -> Set[str]:
        """Get all folders associated with a prefix."""
        return self.prefix_configs.get(prefix, set()).copy()
    
    def is_valid_prefix_word(self, word: str) -> bool:
        """Check if a word is a configured prefix."""
        return word in self.prefix_configs
    
    def export_to_csv(self, filepath: str) -> bool:
        """
        Export prefix configurations to CSV file.
        
        Format:
        prefix,folder1|folder2|folder3
        """
        try:
            with open(filepath, 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(['prefix', 'folders'])  # Header
                
                for prefix, folders in self.prefix_configs.items():
                    writer.writerow([prefix, '|'.join(folders)])
            return True
        except Exception as e:
            print(f"Error exporting prefixes: {e}")
            return False
    
    def import_from_csv(self, filepath: str) -> bool:
        """
        Import prefix configurations from CSV file.
        
        Expected format:
        prefix,folder1|folder2|folder3
        """
        try:
            new_configs = {}
            with open(filepath, 'r', newline='') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    prefix = row['prefix']
                    if self._is_valid_prefix(prefix):
                        folders = set(row['folders'].split('|'))
                        new_configs[prefix] = folders
            
            self.prefix_configs = new_configs
            self._save_prefixes()
            return True
        except Exception as e:
            print(f"Error importing prefixes: {e}")
            return False
    
    def check_folder_exists(self, base_path: str, folder: str) -> bool:
        """
        Check if a configured folder still exists.
        
        Args:
            base_path: Base search path
            folder: Relative folder path to check
            
        Returns:
            bool: True if folder exists
        """
        full_path = Path(base_path) / folder
        return full_path.exists() and full_path.is_dir()
    
    def verify_folders_exist(self, base_path: str) -> List[tuple[str, str]]:
        """
        Verify all configured folders exist.
        
        Args:
            base_path: Base search path
            
        Returns:
            List of (prefix, folder) pairs for missing folders
        """
        missing = []
        for prefix, folders in self.prefix_configs.items():
            for folder in folders:
                if not self.check_folder_exists(base_path, folder):
                    missing.append((prefix, folder))
        return missing

    def is_folder_excluded(self, folder: str) -> bool:
        """
        Check if a folder is excluded from general searches.
        """
        # Check if folder itself is excluded (direct match)
        if folder in self.excluded_folders:
            return True
        
        # Check if folder is a subfolder of any excluded folder
        for excluded in self.excluded_folders:
            # Skip empty folders
            if not excluded:
                continue
            # Check if this is a subfolder (using path separator handling)
            if folder.startswith(excluded + '/') or folder.startswith(excluded + '\\'):
                return True
        
        # If we reach here, the folder is not excluded
        return False
    
    def set_folder_exclusion(self, folder: str, excluded: bool) -> None:
        """
        Set whether a folder should be excluded from general searches.
        Handles parent-child folder relationships intelligently.
        """
        if excluded:
            # Check if a parent folder is already excluded
            for excluded_folder in self.excluded_folders:
                if not excluded_folder:
                    continue
                if folder.startswith(excluded_folder + '/') or folder.startswith(excluded_folder + '\\'):
                    # Parent is already excluded, this folder is implicitly excluded
                    return
            
            # Add this folder to exclusions
            self.excluded_folders.add(folder)
            
            # Remove any subfolders from exclusions as they're now implicitly excluded
            subfolders_to_remove = []
            for excluded_folder in self.excluded_folders:
                if not excluded_folder or excluded_folder == folder:
                    continue
                if excluded_folder.startswith(folder + '/') or excluded_folder.startswith(folder + '\\'):
                    subfolders_to_remove.append(excluded_folder)
            
            for subfolder in subfolders_to_remove:
                self.excluded_folders.discard(subfolder)
        else:
            # Just remove the folder from exclusions
            self.excluded_folders.discard(folder)
            
        self._save_prefixes()

class ShortcutDialog(QDialog):
    """
    Dialog for configuring global keyboard shortcuts.
    
    Uses a QLineEdit in read-only mode to capture keystrokes, converting them
    into a format suitable for the keyboard library while providing a clean UI
    for shortcut configuration.
    """
    
    def __init__(self, current_shortcut: str, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Set Window Focus Shortcut")
        self.setModal(True)
        
        # Store the shortcut in keyboard library format
        self.shortcut = current_shortcut
        
        # Setup UI
        layout = QVBoxLayout(self)
        
        # Instructions
        instructions = QLabel(
            "Press the desired key combination.\n"
            "The shortcut will be updated when you click OK."
        )
        instructions.setWordWrap(True)
        layout.addWidget(instructions)
        
        # Shortcut input field
        self.shortcut_input = QLineEdit()
        self.shortcut_input.setReadOnly(True)
        self.shortcut_input.setText(self._format_shortcut_for_display(current_shortcut))
        layout.addWidget(self.shortcut_input)
        
        # Dialog buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | 
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
        # Initialize with empty modifiers
        self.current_modifiers = set()
    
    def _format_shortcut_for_display(self, shortcut: str) -> str:
        """Convert keyboard library format to display format."""
        # Split combination into parts
        parts = shortcut.split('+')
        # Capitalize each part for display
        return ' + '.join(part.capitalize() for part in parts)
    
    def _format_shortcut_for_storage(self, modifiers: set, key: str) -> str:
        """Convert captured keystroke into keyboard library format."""
        parts = list(modifiers) + [key.lower()]
        return '+'.join(parts)
    
    def keyPressEvent(self, event: QKeyEvent) -> None:
        """
        Handle keystroke capture with comprehensive key support.
        
        Maps Qt key codes to keyboard library compatible strings while preventing
        event propagation. Supports standard keys, special characters, and modifiers
        with precise Qt constant mappings.
        """
        # Prevent event propagation
        event.accept()
        
        # Only process new keystrokes, not auto-repeats
        if not event.isAutoRepeat():
            self.current_modifiers.clear()
            
            # Map modifiers with precise Qt constants
            if event.modifiers() & Qt.KeyboardModifier.ControlModifier:
                self.current_modifiers.add('ctrl')
            if event.modifiers() & Qt.KeyboardModifier.AltModifier:
                self.current_modifiers.add('alt')
            if event.modifiers() & Qt.KeyboardModifier.ShiftModifier:
                self.current_modifiers.add('shift')
            
            # Get the main key
            key = None
            
            # Handle different key categories with precise Qt constants
            if Qt.Key.Key_A <= event.key() <= Qt.Key.Key_Z:
                # Letter keys: map to lowercase
                key = chr(event.key()).lower()
            elif Qt.Key.Key_0 <= event.key() <= Qt.Key.Key_9:
                # Number keys: direct mapping
                key = chr(event.key())
            elif Qt.Key.Key_F1 <= event.key() <= Qt.Key.Key_F12:
                # Function keys: calculate F-key number
                key = f'f{event.key() - Qt.Key.Key_F1 + 1}'
            else:
                # Special keys mapping using verified Qt constants
                key = {
                    Qt.Key.Key_Space: 'space',
                    Qt.Key.Key_Tab: 'tab',
                    Qt.Key.Key_Return: 'enter',
                    Qt.Key.Key_Enter: 'enter',
                    Qt.Key.Key_Backspace: 'backspace',
                    Qt.Key.Key_Delete: 'delete',
                    Qt.Key.Key_Escape: 'esc',
                    Qt.Key.Key_Up: 'up',
                    Qt.Key.Key_Down: 'down',
                    Qt.Key.Key_Left: 'left',
                    Qt.Key.Key_Right: 'right',
                    Qt.Key.Key_QuoteLeft: '`',  # Backtick key
                    Qt.Key.Key_Minus: '-',
                    Qt.Key.Key_Equal: '=',
                    Qt.Key.Key_BracketLeft: '[',
                    Qt.Key.Key_BracketRight: ']',
                    Qt.Key.Key_Semicolon: ';',
                    Qt.Key.Key_Apostrophe: "'",  # Corrected from Key_Quote
                    Qt.Key.Key_Comma: ',',
                    Qt.Key.Key_Period: '.',
                    Qt.Key.Key_Slash: '/',
                    Qt.Key.Key_Backslash: '\\',
                }.get(event.key())
            
            # Update shortcut if we have a valid key combination
            if key and (self.current_modifiers or key in {f'f{i}' for i in range(1, 13)}):
                self.shortcut = self._format_shortcut_for_storage(
                    self.current_modifiers, key
                )
                self.shortcut_input.setText(
                    self._format_shortcut_for_display(self.shortcut)
                )

class SearchResultItem(QListWidgetItem):
    """
    Enhanced list item for displaying search results with folder context.
    
    This widget provides:
    1. Sophisticated document metadata display
    2. Folder path context when relevant
    3. Visual hierarchy between filename and folder path
    """
    
    def __init__(self, doc_info: DocumentInfo):
        # Initialize with empty text - we'll set it in format_display
        super().__init__()
        self.doc_info = doc_info
        self.format_display()
        
        # Store the full path as item data for activation handling
        self.setData(Qt.ItemDataRole.UserRole, str(doc_info.path))
    
    def format_display(self):
        """
        Format the display text with intelligent folder path handling.
        
        Creates a visually hierarchical display with:
        - Filename as primary information
        - Folder path as secondary context when available
        """
        display_text = self.doc_info.name
        
        # Add folder context if available
        if self.doc_info.relative_path:
            display_text = f"{display_text}  [{self.doc_info.relative_path}]"
        
        self.setText(display_text)
        
        # Optional: Add tooltip with full metadata
        tooltip = (
            f"Name: {self.doc_info.name}\n"
            f"Path: {self.doc_info.relative_path}\n"
            f"Size: {self.doc_info.size:,} bytes\n"
            f"Modified: {datetime.fromtimestamp(self.doc_info.last_modified).strftime('%Y-%m-%d %H:%M:%S')}"
        )
        
        # Add hierarchy info to tooltip if available
        if hasattr(self.doc_info, 'original_doc_path') and self.doc_info.original_doc_path:
            tooltip += f"\nFrom document: {Path(self.doc_info.original_doc_path).name}"
            
        self.setToolTip(tooltip)

class SearchInputWithKeyNavigation(QLineEdit):
    """
    Enhanced QLineEdit that intelligently handles keyboard navigation and prefix highlighting.
    """
    
    ctrlEnterPressed = pyqtSignal()
    
    def __init__(self, results_list: QListWidget, prefix_manager: PrefixManager, parent=None):
        super().__init__(parent)
        self.results_list = results_list
        self.prefix_manager = prefix_manager
        
        # Cache for efficient prefix validation
        self.current_prefix = None
        self.prefix_valid = False
        
        # Style configurations
        self.default_style = self.styleSheet()
        self.prefix_style = """
            QLineEdit {
                background-color: #2e7d32;
                color: white;
                padding: 2px 5px;
                border: 1px solid #1b5e20;
            }
        """
        
        # Keys that should be forwarded to the results list
        self.navigation_keys = {
            Qt.Key.Key_Up,
            Qt.Key.Key_Down,
            Qt.Key.Key_PageUp,
            Qt.Key.Key_PageDown
        }
        
        # Connect text change handler
        self.textChanged.connect(self._handle_text_changed)

    def _handle_text_changed(self, text: str):
        """Handle text changes with prefix detection and styling."""
        self.current_prefix = None
        self.prefix_valid = False
        
        # Reset styling if empty
        if not text:
            self.setStyleSheet(self.default_style)
            return
            
        # Check for potential prefix (word followed by space)
        parts = text.strip().split(maxsplit=1)
        if len(parts) < 2:
            self.setStyleSheet(self.default_style)
            return
            
        potential_prefix = parts[0]
        if self.prefix_manager.is_valid_prefix_word(potential_prefix):
            self.current_prefix = potential_prefix
            self.prefix_valid = True
            self.setStyleSheet(self.prefix_style)
        else:
            self.setStyleSheet(self.default_style)

    def keyPressEvent(self, event: QKeyEvent) -> None:
        """
        Handle key press events with special handling for Ctrl+Enter.
        """
        # Print debug info for key presses - can be removed later
        print(f"Key pressed: {event.key()}, Modifiers: {event.modifiers()}")
        
        # Handle Ctrl+Enter specifically
        if ((event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter) and 
            event.modifiers() == Qt.KeyboardModifier.ControlModifier):
            print("Ctrl+Enter detected")
            self.ctrlEnterPressed.emit()
            event.accept()
            return
            
        if event.key() in self.navigation_keys:
            # Forward the event to the results list and transfer focus
            self.results_list.setFocus()
            
            # For Down key, just focus the current selection in the results list
            if event.key() == Qt.Key.Key_Down and self.results_list.count() > 0:
                # If there's no current item, select the first one
                if self.results_list.currentRow() == -1:
                    self.results_list.setCurrentRow(0)
                
                # Make sure the item is visible
                if self.results_list.currentItem():
                    self.results_list.scrollToItem(
                        self.results_list.currentItem(),
                        QListWidget.ScrollHint.EnsureVisible
                    )
                
                # Event has been handled
                event.accept()
                return
            
            # For other navigation keys, forward the event
            new_event = QKeyEvent(
                QEvent.Type.KeyPress,
                event.key(),
                event.modifiers(),
                event.text(),
                event.isAutoRepeat(),
                event.count()
            )
            self.results_list.keyPressEvent(new_event)
            # Do not return focus to search input - we want to keep focus on the results list
        else:
            # Handle all other keys normally
            super().keyPressEvent(event)
    
    def get_current_prefix(self) -> Optional[str]:
        """Get the currently active prefix if any is valid."""
        return self.current_prefix if self.prefix_valid else None

class PrefixManagerDialog(QDialog):
    """
    Dialog for managing prefix-to-folder mappings with sophisticated validation.
    
    This dialog provides:
    1. Interactive table view of prefix configurations
    2. Real-time validation of prefix inputs
    3. Folder selection integration
    4. Multi-folder support per prefix
    """
    
    def __init__(self, prefix_manager: PrefixManager, base_path: str, parent=None):
        super().__init__(parent)
        self.prefix_manager = prefix_manager
        self.base_path = Path(base_path)
        
        self.setWindowTitle("Prefix Configuration")
        self.setModal(True)  # Modal dialog for focused interaction
        self.setMinimumSize(800, 400)  # Wider dialog for better button layout
        
        self.setup_ui()
        self.load_current_mappings()

    def setup_ui(self):
        """Initialize the user interface with sophisticated layout management."""
        layout = QVBoxLayout(self)
        
        # Instructions label
        instructions = QLabel(
            "Configure prefixes to limit searches to specific folders.\n"
            "Prefixes must be alphanumeric (no spaces or special characters)."
        )
        instructions.setWordWrap(True)
        layout.addWidget(instructions)
        
        # Table for displaying mappings
        self.mappings_table = QTableWidget()
        self.mappings_table.setColumnCount(4)  # Now 4 columns instead of 3
        self.mappings_table.setHorizontalHeaderLabels(['Prefix', 'Folders', 'Exclude from General', 'Actions'])
        
        # Set column widths
        self.mappings_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Fixed)
        self.mappings_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.mappings_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
        self.mappings_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.Fixed)
        self.mappings_table.setColumnWidth(0, 100)  # Prefix column width
        self.mappings_table.setColumnWidth(2, 150)  # Exclude column width
        self.mappings_table.setColumnWidth(3, 300)  # Actions column width
        
        self.mappings_table.setSelectionMode(QTableWidget.SelectionMode.NoSelection)
        layout.addWidget(self.mappings_table)
        
        # Add New Mapping section
        add_frame = QFrame()
        add_layout = QHBoxLayout(add_frame)
        
        self.new_prefix_input = QLineEdit()
        self.new_prefix_input.setPlaceholderText("Enter new prefix")
        self.new_prefix_input.setMaxLength(20)  # Reasonable limit for prefix length
        add_layout.addWidget(self.new_prefix_input)
        
        select_folder_btn = QPushButton("Select Folder")
        select_folder_btn.setMinimumWidth(90)
        select_folder_btn.clicked.connect(self.select_folder_for_new_prefix)
        add_layout.addWidget(select_folder_btn)
        
        layout.addWidget(add_frame)
        
        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | 
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

    def load_current_mappings(self):
        """Load and display current prefix configurations."""
        self.mappings_table.setRowCount(0)  # Clear existing rows
        
        for prefix, folders in self.prefix_manager.prefix_configs.items():
            self.add_mapping_row(prefix, folders)
    
    def add_mapping_row(self, prefix: str, folders: Set[str]):
        """
        Add a new row to the mappings table with sophisticated widget management.
        
        Args:
            prefix: The prefix string
            folders: Set of folder paths associated with the prefix
        """
        row = self.mappings_table.rowCount()
        self.mappings_table.insertRow(row)
        
        # Prefix cell
        prefix_item = QTableWidgetItem(prefix)
        prefix_item.setFlags(prefix_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
        self.mappings_table.setItem(row, 0, prefix_item)
        
        # Folders cell - display as comma-separated list
        folders_text = ", ".join(sorted(folders))
        folders_item = QTableWidgetItem(folders_text)
        folders_item.setFlags(folders_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
        self.mappings_table.setItem(row, 1, folders_item)
        
        # Exclude cell - creates checkboxes for each folder
        exclude_widget = QWidget()
        exclude_layout = QVBoxLayout(exclude_widget)
        exclude_layout.setContentsMargins(4, 4, 4, 4)
        exclude_layout.setSpacing(4)
        
        for folder in sorted(folders):
            checkbox = QCheckBox()
            checkbox.setChecked(self.prefix_manager.is_folder_excluded(folder))
            checkbox.setToolTip(f"Exclude {folder} and all its subfolders from general searches")
            # Use folder name as tooltip instead of checkbox text for cleaner display
            checkbox.setToolTip(folder)
            checkbox.stateChanged.connect(lambda state, f=folder: self.toggle_folder_exclusion(f, state))
            
            # Create a folder label for better display
            folder_label = QLabel(folder.split('/')[-1])
            folder_label.setToolTip(folder)
            
            # Add to a horizontal layout
            folder_row = QHBoxLayout()
            folder_row.addWidget(checkbox)
            folder_row.addWidget(folder_label)
            folder_row.addStretch()
            
            exclude_layout.addLayout(folder_row)
        
        exclude_layout.addStretch()
        self.mappings_table.setCellWidget(row, 2, exclude_widget)
        
        # Actions cell
        actions_widget = QWidget()
        actions_layout = QHBoxLayout(actions_widget)
        actions_layout.setContentsMargins(4, 4, 4, 4)
        actions_layout.setSpacing(6)  # Add spacing between buttons
        
        add_folder_btn = QPushButton("Add Folder")
        add_folder_btn.setMinimumWidth(90)
        add_folder_btn.clicked.connect(lambda: self.add_folder_to_prefix(prefix))
        actions_layout.addWidget(add_folder_btn)
        
        remove_folder_btn = QPushButton("Remove Folder")
        remove_folder_btn.setMinimumWidth(90)
        remove_folder_btn.clicked.connect(lambda: self.remove_folder_from_prefix(prefix))
        actions_layout.addWidget(remove_folder_btn)
        
        delete_btn = QPushButton("Delete")
        delete_btn.setMinimumWidth(90)
        delete_btn.clicked.connect(lambda: self.delete_prefix(prefix))
        actions_layout.addWidget(delete_btn)
        
        self.mappings_table.setCellWidget(row, 3, actions_widget)
        
        # Adjust row height to accommodate buttons and checkboxes
        self.mappings_table.setRowHeight(row, max(actions_widget.sizeHint().height() + 8, 
                                                 exclude_widget.sizeHint().height() + 8))

    def toggle_folder_exclusion(self, folder: str, state: int):
        """Toggle exclusion state for a folder."""
        # Convert Qt.CheckState to boolean (2 = Qt.Checked, 0 = Qt.Unchecked)
        excluded = state == Qt.CheckState.Checked.value
        self.prefix_manager.set_folder_exclusion(folder, excluded)

    def select_folder_for_new_prefix(self):
        """Handle folder selection for new prefix with validation."""
        prefix = self.new_prefix_input.text().strip()
        
        if not prefix:
            QMessageBox.warning(
                self,
                "Invalid Prefix",
                "Please enter a prefix before selecting a folder."
            )
            return
        
        if not self.prefix_manager._is_valid_prefix(prefix):
            QMessageBox.warning(
                self,
                "Invalid Prefix",
                "Prefix must contain only alphanumeric characters (no spaces)."
            )
            return
        
        # Show folder selection dialog
        folder = QFileDialog.getExistingDirectory(
            self,
            "Select Folder for Prefix",
            str(self.base_path),
            QFileDialog.Option.ShowDirsOnly
        )
        
        if folder:
            try:
                rel_path = str(Path(folder).relative_to(self.base_path))
                
                # Add new prefix-folder mapping
                self.prefix_manager.add_prefix_folder(prefix, rel_path)
                
                # Explicitly ensure it's not excluded by default
                self.prefix_manager.set_folder_exclusion(rel_path, False)
                
                # Clear input and refresh display
                self.new_prefix_input.clear()
                self.load_current_mappings()
                
            except ValueError:
                QMessageBox.warning(
                    self,
                    "Invalid Folder",
                    "Selected folder must be within the base search directory."
                )

    def add_folder_to_prefix(self, prefix: str):
        """Add another folder to an existing prefix."""
        folder = QFileDialog.getExistingDirectory(
            self,
            f"Select Additional Folder for Prefix '{prefix}'",
            str(self.base_path),
            QFileDialog.Option.ShowDirsOnly
        )
        
        if folder:
            try:
                rel_path = str(Path(folder).relative_to(self.base_path))
                
                # Add new prefix-folder mapping
                self.prefix_manager.add_prefix_folder(prefix, rel_path)
                
                # Explicitly ensure it's not excluded by default
                self.prefix_manager.set_folder_exclusion(rel_path, False)
                
                # Clear input and refresh display
                self.load_current_mappings()
            except ValueError:
                QMessageBox.warning(
                    self,
                    "Invalid Folder",
                    "Selected folder must be within the base search directory."
                )

    def remove_folder_from_prefix(self, prefix: str):
        """Remove a folder from a prefix with user selection."""
        folders = sorted(self.prefix_manager.get_folders_for_prefix(prefix))
        if not folders:
            return
        
        # If only one folder, remove it directly
        if len(folders) == 1:
            self.prefix_manager.remove_prefix_folder(prefix, folders[0])
            self.load_current_mappings()
            return
        
        # For multiple folders, show selection dialog
        folder, ok = QInputDialog.getItem(
            self,
            f"Remove Folder from Prefix '{prefix}'",
            "Select folder to remove:",
            folders,
            0,
            False
        )
        
        if ok and folder:
            self.prefix_manager.remove_prefix_folder(prefix, folder)
            self.load_current_mappings()

    def delete_prefix(self, prefix: str):
        """Delete a prefix and all its folder mappings."""
        reply = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the prefix '{prefix}' and all its folder mappings?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Get all folders and remove them
            folders = self.prefix_manager.get_folders_for_prefix(prefix)
            for folder in folders:
                self.prefix_manager.remove_prefix_folder(prefix, folder)
            
            self.load_current_mappings()

    def accept(self):
        """Handle dialog acceptance with validation."""
        # Verify all folders still exist
        missing = self.prefix_manager.verify_folders_exist(self.base_path)
        if missing:
            message = "The following folders no longer exist:\n\n"
            for prefix, folder in missing:
                message += f"Prefix '{prefix}' -> folder '{folder}'\n"
            message += "\nDo you want to remove these invalid mappings?"
            
            reply = QMessageBox.question(
                self,
                "Missing Folders",
                message,
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                for prefix, folder in missing:
                    self.prefix_manager.remove_prefix_folder(prefix, folder)
        
        super().accept()

class DocumentContextList(QListWidget):
    """
    List widget for displaying document context (related documents from the same source).
    """
    itemActivated = pyqtSignal(QListWidgetItem)  # Standard activation (Enter key)
    ctrlEnterPressed = pyqtSignal(QListWidgetItem)  # For alternate paste mode
    closeContextView = pyqtSignal()  # Signal to close the context view (Right arrow)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        
    def keyPressEvent(self, event: QKeyEvent) -> None:
        """Handle key press events with special handling for navigation."""
        # Handle standard activation with Enter
        if (event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter) and event.modifiers() == Qt.KeyboardModifier.NoModifier:
            current_item = self.currentItem()
            if current_item:
                self.itemActivated.emit(current_item)
                event.accept()
                return
                
        # Handle Ctrl+Enter for alternate paste mode
        elif ((event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter) and 
              event.modifiers() == Qt.KeyboardModifier.ControlModifier):
            current_item = self.currentItem()
            if current_item:
                self.ctrlEnterPressed.emit(current_item)
                event.accept()
                return
        
        # Handle Right arrow to exit context view
        elif event.key() == Qt.Key.Key_Right and event.modifiers() == Qt.KeyboardModifier.NoModifier:
            self.closeContextView.emit()
            event.accept()
            return
            
        # Handle all other keys normally
        super().keyPressEvent(event)

class EnhancedResultsList(QListWidget):
    """
    Enhanced list widget that handles Ctrl+Enter for alternate paste mode
    and Left arrow for showing document context.
    """
    ctrlEnterPressed = pyqtSignal(QListWidgetItem)
    showDocumentContext = pyqtSignal(DocumentInfo)  # New signal for context view
    focusSearchInput = pyqtSignal()  # Signal to request focus back to search input
    
    def keyPressEvent(self, event: QKeyEvent) -> None:
        """Handle key press events with special handling for navigation."""
        # Handle Ctrl+Enter for alternate paste mode
        if ((event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter) and 
            event.modifiers() == Qt.KeyboardModifier.ControlModifier):
            current_item = self.currentItem()
            if current_item:
                self.ctrlEnterPressed.emit(current_item)
                event.accept()
                return
        
        # Handle Left arrow for showing document context
        elif event.key() == Qt.Key.Key_Left and event.modifiers() == Qt.KeyboardModifier.NoModifier:
            current_item = self.currentItem()
            if current_item and hasattr(current_item, 'doc_info'):
                self.showDocumentContext.emit(current_item.doc_info)
                event.accept()
                return
        
        # Handle Up key when at the first item - return focus to search input
        elif event.key() == Qt.Key.Key_Up and self.currentRow() == 0:
            self.focusSearchInput.emit()  # Request focus back to search input
            event.accept()
            return
                
        # Handle all other keys normally
        super().keyPressEvent(event)

class WordHandler:
    """
    Manages Word automation with sophisticated state management and error handling.
    
    This class provides a robust interface for Word operations, carefully managing
    COM object lifecycles and application state to prevent interference with
    user's existing Word sessions. It supports multiple paste modes and implements
    careful state preservation during document operations.
    """
    
    def __init__(self):
        self._app_state: Dict[str, Any] = {}
    
    @contextmanager
    def word_session(self):
        """
        Context manager for Word application sessions with state preservation.
        
        Carefully manages COM initialization and cleanup while preserving
        existing Word application state. Uses a sophisticated state tracking
        system to ensure reliable cleanup even in error cases.
        """
        pythoncom.CoInitialize()
        try:
            try:
                word_app = win32com.client.GetActiveObject("Word.Application")
            except pythoncom.com_error:
                word_app = win32com.client.Dispatch("Word.Application")
            
            # Store and optimize display settings
            self._store_application_state(word_app)
            self._optimize_application_display(word_app)
            
            yield word_app
            
        finally:
            if 'word_app' in locals():
                self._restore_application_state(word_app)
                try:
                    word_app.ScreenUpdating = True
                except:
                    pass

            pythoncom.CoUninitialize()
    
    def _store_application_state(self, word_app):
        """Store essential application display settings."""
        self._app_state = {
            'screen_updating': word_app.ScreenUpdating,
            'display_alerts': word_app.DisplayAlerts
        }
    
    def _optimize_application_display(self, word_app):
        """Optimize display settings for background operation."""
        word_app.ScreenUpdating = False
        word_app.DisplayAlerts = False
    
    def _restore_application_state(self, word_app):
        """Carefully restore previous application state."""
        for prop, value in self._app_state.items():
            try:
                if value is not None:
                    setattr(word_app, prop, value)
            except Exception:
                continue

    @contextmanager
    def open_document(self, word_app, file_path: str, readonly: bool = True):
        """
        Context manager for document operations with proper state management.
        
        Args:
            word_app: Word application instance
            file_path: Path to the document
            readonly: Whether to open in readonly mode (default: True)
        """
        doc = None
        try:
            abs_path = str(Path(file_path).resolve())
            doc = word_app.Documents.Open(
                abs_path,
                ReadOnly=readonly,
                AddToRecentFiles=False,
                NoEncodingDialog=True
            )
            yield doc
        finally:
            if doc is not None:
                try:
                    doc.Close(SaveChanges=not readonly)
                except Exception:
                    pass
    
    def get_active_documents(self) -> List[ActiveDocument]:
        """
        Enumerate currently open documents in Word with robust COM property access.
        
        Returns a list of ActiveDocument objects representing all open documents,
        carefully handling COM interaction to prevent state corruption.
        """
        active_docs = []
        try:
            with self.word_session() as word_app:
                # First verify we have documents open
                if not word_app.Documents.Count:
                    return []

                # Enumerate all open documents with careful property access
                for i, doc in enumerate(word_app.Documents, start=1):
                    try:
                        # Get document name (most reliable property)
                        name = doc.Name

                        # Get full path with error handling
                        try:
                            path = doc.FullName
                        except Exception:
                            path = name  # Fallback to name if path unavailable

                        # Generate a unique identifier using multiple approaches
                        doc_id = None
                        try:
                            # Try getting built-in UniqueID first
                            doc_id = str(doc.UniqueID)
                        except Exception:
                            try:
                                # Fallback to hash of document properties
                                doc_id = f"{name}_{path}_{doc.Saved}_{doc.Windows.Count}"
                            except Exception:
                                # Last resort: use combination of index and name
                                doc_id = f"doc_{i}_{name}"

                        active_docs.append(ActiveDocument(
                            name=name,
                            path=path,
                            window_index=i,
                            doc_id=doc_id
                        ))
                    except Exception as e:
                        print(f"Error accessing document {i}: {str(e)}")
                        continue
                try:
                    word_app.ScreenUpdating = True
                except:
                    pass

        except Exception as e:
            print(f"Error enumerating documents: {str(e)}")
            try:
                # Create a new connection just to restore screen updating
                word_app = win32com.client.GetActiveObject("Word.Application")
                word_app.ScreenUpdating = True
            except:
                pass
        
        return active_docs

    def copy_to_clipboard(self, file_path: str) -> bool:
        """Copy document content to clipboard."""
        try:
            with self.word_session() as word_app:
                with self.open_document(word_app, file_path) as doc:
                    doc.Content.Copy()
                return True
        except Exception as e:
            print(f"Error copying to clipboard: {e}")
            return False

    def transfer_content(self, source_path: str, target_path: str) -> bool:
        """
        Transfer content between documents with formatting preservation.
        
        Args:
            source_path: Path to source document
            target_path: Path to target document
            
        Returns:
            bool: True if transfer succeeded, False otherwise
        """
        try:
            with self.word_session() as word_app:
                # Copy content from source
                with self.open_document(word_app, source_path) as source_doc:
                    source_doc.Content.Copy()
                
                # Paste to target with formatting
                with self.open_document(word_app, target_path, readonly=False) as target_doc:
                    end_point = target_doc.Content.End - 1
                    target_doc.Range(end_point, end_point).Select()
                    
                    # Add spacing for content separation
                    selection = word_app.Selection
                    selection.InsertParagraphBefore()
                    selection.InsertParagraphBefore()
                    selection.Collapse(0)  # Collapse to end
                    
                    # Paste with original formatting
                    selection.PasteAndFormat(16)  # wdFormatOriginalFormatting
                
                return True
        
        except Exception as e:
            print(f"Error transferring content: {e}")
            return False

    def paste_to_active_document(self, source_path: str, target_doc_id: str, mode: str = PasteMode.CURSOR) -> bool:
        """
        Paste content at current cursor position in target document, with precise cursor positioning.
        
        Args:
            source_path: Path to source document
            target_doc_id: Composite identifier of target document
            mode: Paste mode (cursor or end position)
            
        Returns:
            bool: True if paste operation succeeded
        """
        try:
            with self.word_session() as word_app:
                # First, copy source content
                with self.open_document(word_app, source_path) as source_doc:
                    source_doc.Content.Copy()
                
                # Find target document
                target_doc = None
                for doc in word_app.Documents:
                    try:
                        if (doc.Name in target_doc_id or 
                            (hasattr(doc, 'FullName') and doc.FullName in target_doc_id)):
                            target_doc = doc
                            break
                    except Exception:
                        continue
                
                if not target_doc:
                    print(f"Target document not found: {target_doc_id}")
                    return False
                
                # Store original window state (but not selection)
                try:
                    original_window = word_app.ActiveWindow
                except Exception:
                    original_window = None
                
                try:
                    # Activate document
                    target_doc.Activate()
                    
                    if mode == PasteMode.END:
                        # Move to end of document
                        end_point = target_doc.Content.End - 1
                        target_doc.Range(end_point, end_point).Select()
                        
                        # Add spacing for content separation
                        selection = word_app.Selection
                        selection.InsertParagraphBefore()
                        selection.InsertParagraphBefore()
                        selection.Collapse(0)  # Collapse to end
                    
                    # Store the starting point of our paste operation
                    try:
                        start_point = word_app.Selection.Start
                    except Exception:
                        start_point = None
                    
                    # Paste with formatting preservation
                    word_app.Selection.PasteAndFormat(16)  # wdFormatOriginalFormatting
                    
                    # Important: Move cursor to end of pasted content
                    try:
                        if start_point is not None:
                            # Find the end of what we just pasted
                            current_selection = word_app.Selection
                            # Select from start of our paste to current position
                            pasted_range = target_doc.Range(start_point, current_selection.End)
                            # Move to the end of what we pasted
                            pasted_range.Collapse(0)  # 0 = Collapse to end
                            pasted_range.Select()
                    except Exception as e:
                        print(f"Warning: Could not position cursor after paste: {e}")
                    
                    return True
                    
                finally:
                    # Restore original window if needed
                    try:
                        if original_window:
                            original_window.Activate()
                    except Exception:
                        pass
                
        except Exception as e:
            print(f"Error pasting to active document: {str(e)}")
            return False

class DocumentSearcher:
    def __init__(self, folder_path: str, prefix_manager: PrefixManager):
        self.folder_path = Path(folder_path)
        self.document_index: Dict[str, DocumentInfo] = {}
        self.word_handler = WordHandler()
        self.min_token_length = 2  # Minimum length for search tokens
        self.prefix_manager = prefix_manager
        self.index_creation_time = 0  # Timestamp when the index was last created
    
    def index_documents(self, progress_callback=None):
        """Build comprehensive document index with enhanced metadata using multithreading."""
        self.document_index.clear()
        self.index_creation_time = datetime.now().timestamp()  # Record creation time
        
        # Use a thread-safe dictionary for collecting results
        from threading import Lock
        from concurrent.futures import ThreadPoolExecutor
        import json
        
        result_dict = {}
        result_lock = Lock()
        errors = []
        
        def process_file(file_data):
            file_idx, total, file_path = file_data
            try:
                # Report progress periodically
                if progress_callback and file_idx % 10 == 0:
                    progress_callback(file_idx, total)
                elif file_idx % 100 == 0:
                    print(f"Indexing files: {file_idx}/{total}")
                
                # Process file
                file_path_str = str(file_path)
                folder_path_str = str(self.folder_path)
                
                # Get all file stats in a single system call
                try:
                    stats = file_path.stat()
                except (PermissionError, FileNotFoundError) as e:
                    errors.append(f"Error accessing {file_path}: {e}")
                    return None
                
                # Calculate relative path efficiently - use cached folder path
                if file_path_str.startswith(folder_path_str):
                    rel_path_str = file_path_str[len(folder_path_str):].lstrip('\\/').rsplit('\\', 1)[0].rsplit('/', 1)[0]
                    rel_path = rel_path_str
                else:
                    rel_path = ''
                
                # Create basic document info
                doc_info = DocumentInfo(
                    path=file_path,
                    name=file_path.name,
                    last_modified=stats.st_mtime,
                    created_time=stats.st_ctime,
                    size=stats.st_size,
                    relative_path=rel_path,
                    indexed_timestamp=self.index_creation_time
                )
                
                # Try to read hierarchy metadata if it exists - with optimizations
                # First check for filename.docx.meta.json format
                meta_file_path_str = file_path_str + '.meta.json'
                meta_file_path = Path(meta_file_path_str)
                
                # If that doesn't exist, try filename.meta.json format
                if not meta_file_path.exists() and file_path_str.lower().endswith('.docx'):
                    meta_file_path_str = file_path_str[:-5] + '.meta.json'
                    meta_file_path = Path(meta_file_path_str)
                
                # Read metadata if it exists
                if meta_file_path.exists():
                    try:
                        with open(meta_file_path, 'r', encoding='utf-8') as f:
                            metadata = json.load(f)
                        
                        # Apply metadata to document info - direct assignment is faster
                        # Set attrs in bulk to minimize Python object property access overhead
                        for key in ['original_doc_path', 'position_in_original', 'parent_doc_name', 
                                  'sibling_docs', 'is_index_generated', 'source_file_mtime', 'indexed_timestamp']:
                            if key in metadata:
                                setattr(doc_info, key, metadata[key])
                        
                        # Special handling for Path objects
                        if 'source_file' in metadata and metadata['source_file']:
                            doc_info.source_file = Path(metadata['source_file'])
                            
                    except Exception as e:
                        errors.append(f"Error reading metadata for {file_path}: {e}")
                
                # Return document key and info for safe collection
                return (file_path.stem.lower(), doc_info)
                
            except Exception as e:
                errors.append(f"Error processing {file_path}: {e}")
                return None
        
        try:
            # First, collect all .docx files to process
            print("Scanning for document files...")
            docx_files = list(self.folder_path.glob("**/*.docx"))
            total_files = len(docx_files)
            print(f"Found {total_files} documents to index")
            
            # Prepare data for multiprocessing
            file_data = [(i, total_files, path) for i, path in enumerate(docx_files, 1)]
            
            # Process files in parallel using a thread pool
            # Use max workers based on CPU count, but limit to prevent excessive context switching
            max_workers = min(32, (os.cpu_count() or 4) * 4)
            print(f"Using {max_workers} worker threads for indexing")
            
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                # Process files in parallel and collect results
                for result in executor.map(process_file, file_data):
                    if result:
                        key, info = result
                        with result_lock:
                            result_dict[key] = info
            
            # Combine results into the main index
            self.document_index.update(result_dict)
            
            # Report errors if any
            if errors:
                print(f"\nEncountered {len(errors)} errors during indexing:")
                for i, error in enumerate(errors[:10]):  # Show first 10 errors
                    print(f"  {i+1}. {error}")
                if len(errors) > 10:
                    print(f"  ... and {len(errors) - 10} more errors")
            
            # Final progress report
            if progress_callback:
                progress_callback(total_files, total_files)
            print(f"Indexed {len(self.document_index)} documents successfully")
            
        except Exception as e:
            print(f"Critical error during document indexing: {e}")
            import traceback
            traceback.print_exc()
            raise

    def _extract_prefix(self, query: str) -> tuple[Optional[str], str]:
        """
        Extract prefix and remaining search terms from query.
        
        Args:
            query: Raw search query
            
        Returns:
            Tuple of (prefix if found, remaining search terms)
        """
        if not query:
            return None, ""
            
        # Split on first space
        parts = query.strip().split(maxsplit=1)
        if len(parts) != 2:
            return None, query.strip()
            
        potential_prefix, remainder = parts
        
        # Check if the first word is a valid prefix
        if self.prefix_manager.is_valid_prefix_word(potential_prefix):
            return potential_prefix, remainder.strip()
            
        return None, query.strip()

    def search(self, query: str, sort_key: str = None, reverse: bool = False, include_path: bool = False) -> List[DocumentInfo]:
        """
        Perform sophisticated multi-token search with optional sorting and prefix filtering.
        
        Args:
            query: Space-separated search terms, optionally starting with prefix
            sort_key: Optional key for sorting ('name', 'modified', 'created', 'size')
            reverse: Whether to reverse the sort order
            include_path: Whether to include path name in search text
            
        Returns:
            List of matching DocumentInfo objects, sorted if requested
        """
        # Handle empty query - now filters out excluded folders
        if not query.strip():
            results = []
            for doc in self.document_index.values():
                # Skip excluded folders when no prefix is used
                if not self.prefix_manager.is_folder_excluded(doc.relative_path):
                    results.append(doc)
            return self._sort_results(results, sort_key, reverse)

        # Extract prefix if present
        prefix, search_query = self._extract_prefix(query)
        
        # Get target folders if prefix specified
        target_folders = None
        if prefix:
            target_folders = self.prefix_manager.get_folders_for_prefix(prefix)
            if not target_folders:  # Fallback if prefix has no valid folders
                return []

        # Tokenize and filter search terms
        search_tokens = [
            token.lower() for token in search_query.split()
            if len(token) >= self.min_token_length
        ]
        
        # If all tokens are too short, return empty list
        if not search_tokens:
            return []

        # Perform search with folder filtering
        results = []
        for doc in self.document_index.values():
            # If using a prefix, only include documents from target folders
            if target_folders is not None:
                if not any(doc.relative_path.startswith(folder) for folder in target_folders):
                    continue
            # If no prefix is used, exclude documents from excluded folders
            elif self.prefix_manager.is_folder_excluded(doc.relative_path):
                continue
                
            # Determine what text to search in - either just filename or filename+path
            search_text = doc.search_name
            if include_path and doc.relative_path:
                search_text = f"{search_text} {doc.relative_path.lower()}"
                
            # Check if all tokens match
            if all(token in search_text for token in search_tokens):
                results.append(doc)

        return self._sort_results(results, sort_key, reverse)

    # This method has been temporarily disabled but kept for future reference
    # def update_index(self, template_path: Optional[Path] = None) -> Tuple[int, int, int]:
    #     """
    #     Update the index using a simple "remove and replace" approach.
    #     For each source document that has been modified, we remove all derived files
    #     and reprocess the source document from scratch.
    #     
    #     Args:
    #         template_path: Path to template document to use for updates
    #         
    #     Returns:
    #         Tuple of (updated_count, unchanged_count, error_count)
    #     """
    #     updated_count = 0
    #     unchanged_count = 0
    #     error_count = 0
    #     
    #     # Temporary code to mark files as generated, if they have original_doc_path metadata
    #     for doc_key, doc_info in list(self.document_index.items()):
    #         if doc_info.original_doc_path and not doc_info.is_index_generated:
    #             doc_info.is_index_generated = True
    #             
    #             # Set source file if not set
    #             if not doc_info.source_file:
    #                 source_path = doc_info.original_doc_path
    #                 if isinstance(source_path, str):
    #                     source_path = Path(source_path)
    #                 doc_info.source_file = source_path
    #                 
    #             # Set source file mtime if not set
    #             if not doc_info.source_file_mtime and doc_info.source_file and doc_info.source_file.exists():
    #                 try:
    #                     doc_info.source_file_mtime = doc_info.source_file.stat().st_mtime - 1
    #                 except (PermissionError, FileNotFoundError):
    #                     pass
    #     
    #     # Step 1: Group documents by source file
    #     source_docs_map = {}
    #     for doc_key, doc_info in list(self.document_index.items()):
    #         if doc_info.is_index_generated and doc_info.source_file:
    #             source_path_str = str(doc_info.source_file)
    #             if source_path_str not in source_docs_map:
    #                 source_docs_map[source_path_str] = []
    #             source_docs_map[source_path_str].append(doc_info)
    #     
    #     # Step 2: Check each source file once
    #     for source_path_str, doc_list in source_docs_map.items():
    #         try:
    #             source_path = Path(source_path_str)
    #             
    #             # Skip if source doesn't exist
    #             if not source_path.exists():
    #                 unchanged_count += len(doc_list)
    #                 continue
    #             
    #             # Get first document to determine target level and settings
    #             if not doc_list:
    #                 continue
    #                 
    #             # Check if source file has been modified
    #             source_mtime = source_path.stat().st_mtime
    #             needs_update = False
    #             
    #             # Check if any document needs updating
    #             for doc in doc_list:
    #                 if not doc.source_file_mtime or source_mtime > doc.source_file_mtime:
    #                     needs_update = True
    #                     break
    #             
    #             if not needs_update:
    #                 # None of the documents from this source need updating
    #                 unchanged_count += len(doc_list)
    #                 print(f"Skipping {source_path} - not modified")
    #                 continue
    #             
    #             # Source needs updating - delete all existing files and recreate
    #             print(f"Updating {source_path} - rebuilding index files")
    #             
    #             # Get settings from first document (they should all be the same from one source)
    #             reference_doc = doc_list[0]
    #             heading_level = reference_doc.position_in_original or 3
    #             preserve_hierarchy = False  # Default
    #             create_zip = False  # Default
    #             output_dir = reference_doc.path.parent
    #             
    #             # Create DocxSplitter
    #             splitter = DocxSplitter(
    #                 input_path=source_path,
    #                 template_path=template_path,
    #             )
    #             
    #             # Parse sections at the right level
    #             splitter.parse_sections(heading_level)
    #             
    #             if not splitter.sections:
    #                 print(f"No sections found in {source_path} at level {heading_level}")
    #                 error_count += len(doc_list)
    #                 continue
    #             
    #             # Step 3: Remove all files from this source from the index
    #             for doc in doc_list:
    #                 try:
    #                     # Delete the file
    #                     if doc.path.exists():
    #                         os.remove(doc.path)
    #                         
    #                     # Remove from index
    #                     key = doc.path.stem.lower()
    #                     if key in self.document_index:
    #                         del self.document_index[key]
    #                 except Exception as e:
    #                     print(f"Error removing {doc.path}: {e}")
    #                     error_count += 1
    #             
    #             # Step 4: Process the source document and add new files to index
    #             result_path = splitter.process_document(
    #                 output_dir=output_dir,
    #                 target_level=heading_level,
    #                 create_zip=create_zip,
    #                 preserve_hierarchy=preserve_hierarchy
    #             )
    #             
    #             if result_path:
    #                 # Count the number of new files created
    #                 if create_zip:
    #                     # For ZIP files, we can't count directly
    #                     updated_count += len(splitter.sections)
    #                 else:
    #                     # Count files in output directory with matching modified time
    #                     new_files = list(output_dir.glob("*.docx"))
    #                     updated_count += len(new_files)
    #             else:
    #                 error_count += len(doc_list)
    #             
    #         except Exception as e:
    #             print(f"Error processing source {source_path_str}: {e}")
    #             error_count += len(doc_list)
    #     
    #     # Return stats about the update
    #     # return (updated_count, unchanged_count, error_count)
    #     pass  # Disabled implementation
            
    def get_document_context(self, doc_info: DocumentInfo) -> List[DocumentInfo]:
        """
        Get the document in its original context, with siblings in proper order.
        
        Args:
            doc_info: The document to get context for
            
        Returns:
            List of related documents in original document order
        """
        related_docs = []
        
        # If no hierarchy information, just return the document itself
        if not doc_info.original_doc_path and not doc_info.sibling_docs:
            return [doc_info]
            
        # Add current document
        related_docs.append(doc_info)
        
        # Add sibling documents if available
        for sibling_name in doc_info.sibling_docs:
            # Look for sibling in the index
            sibling_key = sibling_name.lower()
            if sibling_key in self.document_index:
                related_docs.append(self.document_index[sibling_key])
                
        # If we have a parent document, add it too
        if doc_info.parent_doc_name:
            parent_key = doc_info.parent_doc_name.lower()
            if parent_key in self.document_index:
                # Insert parent at the beginning
                related_docs.insert(0, self.document_index[parent_key])
                
        # Sort by position in original document if available
        # Group documents by levels (parent first, then siblings in order)
        # First, sort by whether it's a parent or not
        related_docs.sort(key=lambda d: 0 if d.parent_doc_name else 1)
        
        # Then sort siblings by position
        sorted_docs = []
        # First add parent documents (already at the beginning due to previous sort)
        parent_docs = [d for d in related_docs if not d.parent_doc_name]
        sorted_docs.extend(parent_docs)
        
        # Then add child documents sorted by position
        child_docs = [d for d in related_docs if d.parent_doc_name]
        child_docs.sort(key=lambda d: d.position_in_original if d.position_in_original is not None else float('inf'))
        sorted_docs.extend(child_docs)
        
        return sorted_docs
        
    def _sort_results(
        self,
        results: List[DocumentInfo],
        sort_key: Optional[str],
        reverse: bool
    ) -> List[DocumentInfo]:
        """
        Sort results based on specified criteria.
        
        Implements an extensible sorting system with support for multiple
        sort keys and proper handling of edge cases.
        """
        if not sort_key:
            return results

        # Define sorting key functions
        sort_functions = {
            'name': lambda x: x.name.lower(),
            'modified': lambda x: x.last_modified,
            'created': lambda x: x.created_time,
            'size': lambda x: x.size,
        }

        if sort_key not in sort_functions:
            print(f"Warning: Unknown sort key '{sort_key}', using default ordering")
            return results

        return sorted(
            results,
            key=sort_functions[sort_key],
            reverse=reverse
        )

class DocxSearchApp(QMainWindow):
    """
    Main application window with advanced document handling capabilities.
    
    This class implements a sophisticated document management interface that:
    - Provides real-time search capabilities with prefix-based folder filtering
    - Manages multiple document targeting modes
    - Implements intelligent state persistence
    - Handles complex user interactions with robust error recovery
    """

    hotkey_activated = pyqtSignal()

    def __init__(self):
        super().__init__()

        # First, try to connect to an existing instance
        socket = QLocalSocket()
        socket.connectToServer("DocxSearchAppLock")
        
        # If connection succeeds, another instance exists
        if socket.waitForConnected(500):  # 500ms timeout
            reply = QMessageBox.question(
                None,  # No parent since window isn't created yet
                "Instance Already Running",
                "Another instance of Block Search is already running.\n"
                "Would you like to start another instance?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.No:
                # Clean up and exit
                socket.disconnectFromServer()
                sys.exit(0)
            socket.disconnectFromServer()
        
        # Create server to prevent additional instances
        self.lock_server = QLocalServer(self)
        # Force remove any existing server in case of previous crash
        QLocalServer.removeServer("DocxSearchAppLock")
        # Start listening
        self.lock_server.listen("DocxSearchAppLock")
        
        self.setWindowTitle("Block Search")
        self.hotkey_activated.connect(self.handle_global_hotkey)
        self.setGeometry(100, 100, 800, 600)
        
        # Initialize persistent settings
        self.settings = QSettings('DocxSearchApp', 'Settings')
        
        # Load saved paths and states
        self.search_folder = self.settings.value('search_folder', os.getcwd())
        self.target_document = self.settings.value('target_document', None)
        self.active_target_id = None
        
        # Load shortcut configuration
        self.activation_shortcut = self.settings.value('activation_shortcut', 'ctrl+space')
        
        # Initialize prefix manager before document searcher
        self.prefix_manager = PrefixManager(self.settings)
        
        # Initialize core components with prefix manager
        self.searcher = DocumentSearcher(self.search_folder, self.prefix_manager)
        self.search_delay = 300  # ms for debouncing
        
        # Setup UI components
        self.setup_ui()
        self.setup_menu()
        
        # Initial document indexing
        self.index_documents()
        self._update_target_status()

        # Initialize system tray integration
        self.setup_system_tray()
        
        # Configure global hotkey
        self.setup_global_hotkey()
        
        # Don't show window initially
        self.show()

        # Initialize Win32 API constants
        self.SWP_NOMOVE = 0x0002
        self.SWP_NOSIZE = 0x0001
        self.SWP_NOZORDER = 0x0004
        self.SWP_FRAMECHANGED = 0x0020
        self.SWP_NOOWNERZORDER = 0x0200
        self.HWND_TOP = 0
        
        # Get handle for current window after it's created
        self.window_handle = None
        # Wait until window is properly initialized
        QTimer.singleShot(0, self._store_window_handle)

    def setup_system_tray(self):
        """Initialize system tray integration with sophisticated menu handling."""
        self.tray_icon = QSystemTrayIcon(self)
        
        # Create icon - you'll need to replace with your actual icon path
        icon = QIcon(r"C:\Mac\Home\Desktop\block_sender_icon.ico")
        self.tray_icon.setIcon(icon)
        
        # Create tray menu
        tray_menu = QTrayMenu()
        
        # Add menu actions
        show_action = tray_menu.addAction("Show Search")
        show_action.triggered.connect(self.activate_window)
        
        tray_menu.addSeparator()
        
        quit_action = tray_menu.addAction("Quit")
        quit_action.triggered.connect(self.quit_application)
        
        # Set the menu and make tray icon visible
        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.show()
        
        # Connect double-click behavior
        self.tray_icon.activated.connect(self.on_tray_activated)
    
    def setup_global_hotkey(self):
        """Configure system-wide hotkey using saved shortcut configuration."""
        try:
            # First remove any existing hotkey
            keyboard.unhook_all()
            
            # Register new hotkey
            keyboard.add_hotkey(
                self.activation_shortcut,
                lambda: self.hotkey_activated.emit()
            )
            print(f"Hotkey for {self.activation_shortcut} has been registered successfully.")
        except Exception as e:
            print(f"Failed to register global hotkey: {e}")

    def handle_global_hotkey(self):
        """
        Handle global hotkey press with intelligent window management.
        Focuses window if open but not focused, otherwise toggles visibility.
        """
        if not self.isVisible():
            self.show()
            self.activate_window()
        elif not self.isActiveWindow():
            self.activate_window()
        else:
            self.focus_search()

    def configure_shortcut(self):
        """Show dialog for configuring the global activation shortcut."""
        dialog = ShortcutDialog(self.activation_shortcut, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            new_shortcut = dialog.shortcut
            if new_shortcut != self.activation_shortcut:
                self.activation_shortcut = new_shortcut
                self.settings.setValue('activation_shortcut', new_shortcut)
                self.setup_global_hotkey()  # Reconfigure hotkey immediately

    def show_help(self):
        """Show the help dialog."""
        dialog = HelpDialog(self)
        dialog.exec()

    def show_document_splitter(self):
        """Show the dialog to add files to the index by splitting documents."""
        dialog = AddToIndexDialog(self)
        dialog.exec()
        
        # Refresh document index if the output is in the search folder
    
    def show_update_index(self):
        """Show the dialog to update the document index."""
        dialog = UpdateIndexDialog(self)
        dialog.exec()
        
        # The dialog will refresh the index when processing completes
        
    # update_index method has been removed
    
    # on_update_complete method has been removed

    def _store_window_handle(self):
        """Store the Win32 window handle for later use."""
        self.window_handle = ctypes.windll.user32.GetParent(int(self.winId()))

    def _minimize_without_animation(self):
        """Minimize window without animation using direct Win32 API calls."""
        if self.window_handle:
            # Get current window placement info
            placement = wintypes.WINDOWPLACEMENT()
            placement.length = ctypes.sizeof(placement)
            ctypes.windll.user32.GetWindowPlacement(self.window_handle, ctypes.byref(placement))
            
            # Set minimized state directly
            placement.showCmd = 6  # SW_MINIMIZE
            ctypes.windll.user32.SetWindowPlacement(self.window_handle, ctypes.byref(placement))

    def _restore_without_animation(self):
        """Restore window without animation using direct Win32 API calls."""
        if self.window_handle:
            # Get current window placement info
            placement = wintypes.WINDOWPLACEMENT()
            placement.length = ctypes.sizeof(placement)
            ctypes.windll.user32.GetWindowPlacement(self.window_handle, ctypes.byref(placement))
            
            # Set restored state directly
            placement.showCmd = 1  # SW_NORMAL
            ctypes.windll.user32.SetWindowPlacement(self.window_handle, ctypes.byref(placement))
            
            # Ensure window is actually visible and focused
            flags = self.SWP_NOMOVE | self.SWP_NOSIZE | self.SWP_NOZORDER | \
                   self.SWP_FRAMECHANGED | self.SWP_NOOWNERZORDER
            ctypes.windll.user32.SetWindowPos(
                self.window_handle, 
                self.HWND_TOP, 
                0, 0, 0, 0, 
                flags
            )

    def activate_window(self):
        """
        Window activation with sophisticated Windows focus system integration.
        
        This implementation recognizes that Windows distinguishes between
        "explicit" and "ambient" focus states, and uses different strategies
        based on the current system focus state.
        """
        # First, store our current visibility state
        was_visible = self.isVisible()
        
        # If we're hidden or minimized, we get a "fresh" activation
        if not was_visible or (self.windowState() & Qt.WindowState.WindowMinimized):
            # Clear any existing window states and flags
            self.setWindowState(Qt.WindowState.WindowNoState)
            self.setWindowFlags(self.windowFlags() & ~Qt.WindowType.WindowStaysOnTopHint)
            
            # Show and activate - Windows is more likely to grant focus for newly shown windows
            self.show()
            self.activateWindow()
            self.search_input.setFocus()
        else:
            # For already-visible windows, we need to "release and reclaim" focus
            # This technique temporarily releases our claim on the window
            self.setWindowState(Qt.WindowState.WindowMinimized)
            
            # Use a very short timer to restore - this creates a natural focus transition
            QTimer.singleShot(10, self._restore_from_minimize)

    def _restore_from_minimize(self):
        """
        Restore window from minimized state using Windows-friendly focus claiming.
        
        The key insight is that restoring from a minimized state is treated
        differently by Windows' focus system compared to regular activation.
        """
        # Restore window state - this is a natural focus-claiming action
        self.setWindowState(Qt.WindowState.WindowNoState)
        self.show()
        self.activateWindow()
        
        # Now that we're restored, claim input focus
        self.search_input.setFocus()
        
        # Schedule a final focus check
        QTimer.singleShot(50, self._verify_focus)

    def _verify_focus(self):
        """
        Verify and rectify focus state if necessary.
        
        This final check ensures we achieved proper focus and provides
        a fallback if the main activation attempt failed.
        """
        if not self.search_input.hasFocus():
            self.activateWindow()
            self.search_input.setFocus()

    def focus_search(self):
        """Focus search field with intelligent text selection."""
        # Close context view if it's open
        if self.context_frame.isVisible():
            self.close_document_context()
            
        self.search_input.setFocus()
        self.search_input.selectAll()
    
    def on_tray_activated(self, reason):
        """Handle tray icon activation with platform-aware behavior."""
        if reason == QSystemTrayIcon.ActivationReason.DoubleClick:
            self.activate_window()

    def keyPressEvent(self, event: QKeyEvent):
        """Handle key press events at the main window level."""
        if event.key() == Qt.Key.Key_Escape:
            self.close_window()
            event.accept()
        else:
            super().keyPressEvent(event)

    def close_window(self):
        """Hide the window while keeping the application running."""
        self.hide()
    
    def quit_application(self):
        """Perform clean application shutdown with proper resource cleanup."""
        keyboard.unhook_all()
        self.tray_icon.hide()
        QApplication.quit()
    
    def closeEvent(self, event):
        """Override close event to implement minimize-to-tray behavior."""
        event.ignore()
        self.hide()

    def setup_ui(self):
        """Initialize the user interface with sophisticated component hierarchy."""
        # Create and configure central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        
        # Target status panel with visual hierarchy
        target_frame = QFrame()
        target_frame.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Sunken)
        # Set fixed height for target frame to prevent it from expanding too much
        target_frame.setFixedHeight(40)  # Fixed height in pixels
        target_layout = QHBoxLayout(target_frame)
        # Reduce margins to make the layout more compact
        target_layout.setContentsMargins(5, 3, 5, 3)
        
        target_label = QLabel("Target Document:")
        self.target_status = QLineEdit()
        self.target_status.setReadOnly(True)
        
        target_layout.addWidget(target_label)
        target_layout.addWidget(self.target_status)
        layout.addWidget(target_frame)
        
        # Search components with integrated keyboard navigation
        search_frame = QFrame()
        search_layout = QVBoxLayout(search_frame)
        
        # Create a horizontal splitter to hold search results and context panel
        self.search_splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Initialize results list using our enhanced version
        self.results_list = EnhancedResultsList()
        self.results_list.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        # Connect signals
        self.results_list.itemActivated.connect(self.on_item_activated)
        self.results_list.ctrlEnterPressed.connect(self.on_ctrl_enter_activated)
        self.results_list.showDocumentContext.connect(self.show_document_context)
        self.results_list.focusSearchInput.connect(self.focus_search)
        
        # Create context panel (initially hidden)
        self.context_frame = QFrame()
        self.context_frame.setVisible(False)  # Hidden by default
        context_layout = QVBoxLayout(self.context_frame)
        
        # Create header for context view
        context_header = QFrame()
        context_header_layout = QHBoxLayout(context_header)
        context_header_layout.setContentsMargins(0, 0, 0, 0)
        
        self.context_title = QLabel("Document Context View")
        self.context_title.setStyleSheet("font-weight: bold; color: #2c5aa0;")
        context_header_layout.addWidget(self.context_title)
        
        context_header_layout.addStretch()
        
        # Add close button
        close_context_btn = QPushButton("×")  # Unicode × character
        close_context_btn.setToolTip("Close context view (Right Arrow)")
        close_context_btn.setMaximumWidth(30)
        close_context_btn.clicked.connect(self.close_document_context)
        context_header_layout.addWidget(close_context_btn)
        
        context_layout.addWidget(context_header)
        
        # Add document context list
        self.context_list = DocumentContextList()
        # Connect activate signal (Enter key)
        self.context_list.itemActivated.connect(self.on_context_item_activated)
        # Connect double-click signal explicitly
        self.context_list.itemDoubleClicked.connect(self.on_context_item_activated)
        # Connect other signals
        self.context_list.ctrlEnterPressed.connect(self.on_context_ctrl_enter_activated)
        self.context_list.closeContextView.connect(self.close_document_context)
        context_layout.addWidget(self.context_list)
        
        # Add preview shortcut (Shift+Enter) to context list
        context_preview_shortcut = QShortcut(QKeySequence(Qt.Key.Key_Return | Qt.KeyboardModifier.ShiftModifier), self.context_list)
        context_preview_shortcut.activated.connect(self.show_context_document_preview)
        
        # Add context panel and results list to splitter
        self.search_splitter.addWidget(self.context_frame)
        self.search_splitter.addWidget(self.results_list)
        
        # Set initial sizes (context panel takes less space)
        self.search_splitter.setSizes([0, 1])  # Context panel starts collapsed
        
        # Create enhanced search input with prefix support
        self.search_input = SearchInputWithKeyNavigation(
            self.results_list,
            self.prefix_manager
        )
        self.search_input.setPlaceholderText(
            f"Type to search documents in: {self.search_folder}"
        )
        self.search_input.textChanged.connect(self.on_search_text_changed)
        self.search_input.returnPressed.connect(self.handle_search_return)
        self.search_input.ctrlEnterPressed.connect(self.handle_ctrl_enter)
        
        # Add components to search layout
        search_layout.addWidget(self.search_input)
        search_layout.addWidget(self.search_splitter)
        layout.addWidget(search_frame)
        
        # Initialize status bar for user feedback
        self.statusBar().showMessage("Ready")
        
        # Configure search timer for debounced updates
        self.search_timer = QTimer()
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self.perform_search)

        # Preview shortcut (Shift+Enter)
        preview_shortcut = QShortcut(QKeySequence(Qt.Key.Key_Return | Qt.KeyboardModifier.ShiftModifier), self.results_list)
        preview_shortcut.activated.connect(self.show_document_preview)

    def handle_search_return(self):
        """Handle Return/Enter key in search box with intelligent focus management."""
        if self.results_list.count() > 0:
            current_item = self.results_list.currentItem()
            if current_item:
                # Use the CURRENT default mode
                self.on_item_activated(current_item)
            else:
                first_item = self.results_list.item(0)
                self.results_list.setCurrentItem(first_item)
                self.on_item_activated(first_item)

    def handle_ctrl_enter(self):
        """Handle Ctrl+Enter key in search box to use alternate paste mode."""
        print("Handle Ctrl+Enter called")
        if self.results_list.count() > 0:
            current_item = self.results_list.currentItem()
            if current_item:
                # Use the ALTERNATE mode
                self.on_ctrl_enter_activated(current_item)
            else:
                first_item = self.results_list.item(0)
                self.results_list.setCurrentItem(first_item)
                self.on_ctrl_enter_activated(first_item)

    def process_item_with_alternate_mode(self, item):
        """Process an item with the alternate paste mode."""
        # Get the file path from the item
        file_path = item.data(Qt.ItemDataRole.UserRole)
        success = False
        
        # Get the current paste mode and invert it
        use_cursor_mode = not self.cursor_mode_action.isChecked()
        
        if self.active_target_id:
            # Determine paste mode (inverted from default)
            paste_mode = PasteMode.CURSOR if use_cursor_mode else PasteMode.END
            
            # Paste to active document with the alternate mode
            success = self.searcher.word_handler.paste_to_active_document(
                file_path,
                self.active_target_id,
                mode=paste_mode
            )
            
            mode_str = "cursor position" if paste_mode == PasteMode.CURSOR else "document end"
            status_msg = (
                f"Pasted '{Path(file_path).name}' at {mode_str} (alternate mode)"
                if success
                else f"Error pasting to active document at {mode_str}"
            )
            
        elif self.target_document:
            # For target documents, we still use the standard transfer
            success = self.searcher.word_handler.transfer_content(
                file_path,
                self.target_document
            )
            status_msg = (
                f"Transferred '{Path(file_path).name}' to '{Path(self.target_document).name}'"
                if success
                else "Error transferring content. Check target document."
            )
            
        else:
            # Clipboard mode has no alternate
            success = self.searcher.word_handler.copy_to_clipboard(file_path)
            status_msg = (
                f"Copied '{Path(file_path).name}' to clipboard"
                if success
                else "Error copying to clipboard"
            )
        
        self.statusBar().showMessage(status_msg, 3000)

    def setup_menu(self):
        """Create application menus with comprehensive document management options."""
        menubar = self.menuBar()
        
        # Search settings menu
        settings_menu = menubar.addMenu('Search Settings')
        select_folder_action = settings_menu.addAction('Select Search Folder')
        select_folder_action.triggered.connect(self.select_search_folder)
        show_folder_action = settings_menu.addAction('Show Current Folder')
        show_folder_action.triggered.connect(self.show_current_folder)
        
        reindex_action = settings_menu.addAction('Reindex')
        reindex_action.triggered.connect(self.reindex_documents)
        
        # Add Configure Shortcut option to Settings menu
        settings_menu.addSeparator()
        
        # Add option to include path names in search
        self.include_path_action = settings_menu.addAction('Include Path in Search')
        self.include_path_action.setCheckable(True)
        self.include_path_action.setChecked(self.settings.value('include_path_in_search', False, type=bool))
        self.include_path_action.setShortcut('Ctrl+Shift+P')  # Add keyboard shortcut
        self.include_path_action.triggered.connect(self.toggle_include_path)
        
        configure_shortcut_action = settings_menu.addAction('Set Window Focus Shortcut...')
        configure_shortcut_action.triggered.connect(self.configure_shortcut)
        
        # Add Prefix Configuration submenu
        prefix_menu = settings_menu.addMenu('Prefix Configuration')
        
        manage_prefixes_action = prefix_menu.addAction('Manage Prefixes...')
        manage_prefixes_action.triggered.connect(self.show_prefix_manager)
        
        prefix_menu.addSeparator()
        
        import_prefixes_action = prefix_menu.addAction('Import Prefixes...')
        import_prefixes_action.triggered.connect(self.import_prefixes)
        
        export_prefixes_action = prefix_menu.addAction('Export Prefixes...')
        export_prefixes_action.triggered.connect(self.export_prefixes)
        
        # Add Quit button to Settings menu
        settings_menu.addSeparator()
        quit_action = settings_menu.addAction('Quit')
        quit_action.setShortcuts([QKeySequence("Alt+F4"), QKeySequence("Ctrl+Q")])
        quit_action.triggered.connect(self.quit_application)

        # Index menu
        index_menu = menubar.addMenu('Index')
        
        # Add Files to Index
        add_to_index_action = index_menu.addAction('Add Files to Index...')
        add_to_index_action.triggered.connect(self.show_document_splitter)
        
        # Update Index
        update_index_action = index_menu.addAction('Update Index...')
        update_index_action.triggered.connect(self.show_update_index)
        
        # Target document menu
        target_menu = menubar.addMenu('Send to Closed Doc')
        select_target_action = target_menu.addAction('Select Destination...')
        select_target_action.setShortcut('Ctrl+T')
        select_target_action.triggered.connect(self.select_target_document)
        
        clear_target_action = target_menu.addAction('Clear Destination')
        clear_target_action.setShortcut('Ctrl+Shift+T')
        clear_target_action.triggered.connect(self.clear_target_document)
        
        target_menu.addSeparator()
        show_target_action = target_menu.addAction('Show Destination Info')
        show_target_action.triggered.connect(self.show_target_document)
        
        # Open Documents menu with paste mode options
        open_docs_menu = menubar.addMenu('Send to Open Doc')
        refresh_docs_action = open_docs_menu.addAction('Refresh Open Documents')
        refresh_docs_action.setShortcut('F5')
        refresh_docs_action.triggered.connect(self.refresh_open_documents)
        
        # Auto-refresh when menu is opened
        open_docs_menu.aboutToShow.connect(self.refresh_open_documents)
        
        open_docs_menu.addSeparator()
        
        # Paste mode selection
        self.paste_mode_menu = menubar.addMenu('Default Paste Mode')

        # Create actions with dynamic shortcut display
        self.cursor_mode_action = QAction('Paste at Cursor', self)
        self.cursor_mode_action.setCheckable(True)
        self.cursor_mode_action.setChecked(True)
        
        self.end_mode_action = QAction('Paste at Document End', self)
        self.end_mode_action.setCheckable(True)
        
        # Create action group for mutual exclusivity
        paste_mode_group = QActionGroup(self)
        paste_mode_group.addAction(self.cursor_mode_action)
        paste_mode_group.addAction(self.end_mode_action)
        paste_mode_group.setExclusive(True)
        
        # Connect mode change to shortcut text update
        self.cursor_mode_action.triggered.connect(self._update_paste_mode_shortcuts)
        self.end_mode_action.triggered.connect(self._update_paste_mode_shortcuts)
        
        self.paste_mode_menu.addAction(self.cursor_mode_action)
        self.paste_mode_menu.addAction(self.end_mode_action)
        
        # Add a toggle shortcut action
        self.toggle_paste_mode_action = QAction('Toggle Paste Mode', self)
        self.toggle_paste_mode_action.setShortcut('Ctrl+P')
        self.toggle_paste_mode_action.triggered.connect(self.toggle_paste_mode)
        self.addAction(self.toggle_paste_mode_action)  # Add to application actions
        
        # Add the toggle action to the menu
        self.paste_mode_menu.addSeparator()
        self.paste_mode_menu.addAction(self.toggle_paste_mode_action)
        
        # Initialize shortcut displays
        self._update_paste_mode_shortcuts()
        
        # Store mode references
        open_docs_menu.addSeparator()
        self.open_docs_menu = open_docs_menu
        self.refresh_open_documents()

        # Add Sort menu
        sort_menu = menubar.addMenu('Sort')
        
        # Create sort options
        sort_group = QActionGroup(self)
        sort_group.setExclusive(True)
        
        # Define sort options with their display names and keys
        sort_options = [
            ('Name', 'name'),
            ('Date Modified', 'modified'),
            ('Date Created', 'created'),
            ('Size', 'size')
        ]
        
        # Create actions for each sort option
        self.sort_actions = {}
        for display_name, sort_key in sort_options:
            action = sort_menu.addAction(display_name)
            action.setCheckable(True)
            action.setData(sort_key)
            sort_group.addAction(action)
            self.sort_actions[sort_key] = action
            action.triggered.connect(self.perform_search)
        
        # Set default sort
        self.sort_actions['name'].setChecked(True)
        
        # Add reverse sort option
        sort_menu.addSeparator()
        self.reverse_sort_action = sort_menu.addAction('Reverse Order')
        self.reverse_sort_action.setCheckable(True)
        self.reverse_sort_action.triggered.connect(self.perform_search)
        
        # Add Help menu
        help_menu = menubar.addMenu('Help')
        show_help_action = help_menu.addAction('Show Help')
        show_help_action.setShortcut('F1')  # Standard help shortcut
        show_help_action.triggered.connect(self.show_help)

    def _update_paste_mode_shortcuts(self):
        """
        Update menu items to show appropriate shortcuts based on current default mode.
        """
        if self.cursor_mode_action.isChecked():
            self.cursor_mode_action.setText('Paste at Cursor (Enter)')
            self.end_mode_action.setText('Paste at Document End (Ctrl+Enter)')
        else:
            self.cursor_mode_action.setText('Paste at Cursor (Ctrl+Enter)')
            self.end_mode_action.setText('Paste at Document End (Enter)')

    def toggle_paste_mode(self):
        """Toggle between cursor and end paste modes."""
        if self.cursor_mode_action.isChecked():
            self.end_mode_action.setChecked(True)
        else:
            self.cursor_mode_action.setChecked(True)
        
        # Update the menu labels to reflect the new keyboard shortcuts
        self._update_paste_mode_shortcuts()
        
    def toggle_include_path(self):
        """Toggle whether path names are included in search terms."""
        include_path = self.include_path_action.isChecked()
        self.settings.setValue('include_path_in_search', include_path)
        
        # Show status message
        status = "enabled" if include_path else "disabled"
        self.statusBar().showMessage(f"Path name search {status} (Ctrl+Shift+P)", 3000)
        
        # Re-run search with new setting if search box has content
        if self.search_input.text():
            self.perform_search()

    def on_item_activated(self, item: QListWidgetItem):
        """Handle document selection using current default paste mode."""
        print("Regular item activation")
        file_path = item.data(Qt.ItemDataRole.UserRole)
        
        # Use the current default mode
        use_cursor_mode = self.cursor_mode_action.isChecked()
        self._process_item(file_path, use_cursor_mode)

    def on_ctrl_enter_activated(self, item: QListWidgetItem):
        """Handle document selection using alternate paste mode."""
        print("Ctrl+Enter item activation")
        file_path = item.data(Qt.ItemDataRole.UserRole)
        
        # Use the opposite of the current default mode
        use_cursor_mode = not self.cursor_mode_action.isChecked()
        self._process_item(file_path, use_cursor_mode)

    def show_document_preview(self, item=None):
        """Show preview of the selected document."""
        if item is None:
            item = self.results_list.currentItem()
            
        if not item:
            self.statusBar().showMessage("No document selected to preview", 3000)
            return
            
        file_path = item.data(Qt.ItemDataRole.UserRole)
        
        try:
            # Show preview dialog
            preview_dialog = DocumentPreviewDialog(file_path, self)
            preview_dialog.exec()
        except Exception as e:
            self.statusBar().showMessage(f"Error previewing document: {str(e)}", 5000)
            
    def show_context_document_preview(self):
        """Show preview of the selected document in context view."""
        item = self.context_list.currentItem()
            
        if not item:
            self.statusBar().showMessage("No document selected to preview", 3000)
            return
            
        file_path = item.data(Qt.ItemDataRole.UserRole)
        
        try:
            # Show preview dialog
            preview_dialog = DocumentPreviewDialog(file_path, self)
            preview_dialog.exec()
        except Exception as e:
            self.statusBar().showMessage(f"Error previewing document: {str(e)}", 5000)
            
    def show_document_context(self, doc_info: DocumentInfo):
        """Show document in the context of its original document structure."""
        # Check if document has context information
        related_docs = self.searcher.get_document_context(doc_info)
        
        # If no related documents, just return
        if len(related_docs) <= 1 and not doc_info.original_doc_path:
            self.statusBar().showMessage("No document context available", 3000)
            return
            
        # Clear the context list
        self.context_list.clear()
        
        # Get the index of the current document in the related docs list
        current_index = related_docs.index(doc_info) if doc_info in related_docs else 0
        
        # Set document context title
        if doc_info.original_doc_path:
            self.context_title.setText(f"Context: {Path(doc_info.original_doc_path).name}")
        else:
            self.context_title.setText("Document Context View")
        
        # Populate the context list
        for related_doc in related_docs:
            # Create item with document info
            item = QListWidgetItem()
            item.setText(related_doc.name)
            item.setData(Qt.ItemDataRole.UserRole, str(related_doc.path))
            item.setData(Qt.ItemDataRole.UserRole + 1, related_doc)  # Store doc_info
            
            # Add visual indicator if it's a parent document
            if related_doc.parent_doc_name:
                # Add visual prefix for child documents instead of indent
                item.setText("  ↪ " + item.text())  # Add arrow and spaces for child docs
            else:
                # Make parent docs bold
                font = item.font()
                font.setBold(True)
                item.setFont(font)
                
            self.context_list.addItem(item)
        
        # Select the current document in the context list
        if 0 <= current_index < self.context_list.count():
            self.context_list.setCurrentRow(current_index)
        
        # Apply visual effects to show context mode
        self.results_list.setEnabled(False)  # Disable the main results
        self.results_list.setStyleSheet("QListWidget { background-color: #f0f0f0; color: #808080; }")
        
        # Show context frame and give it focus
        self.context_frame.setVisible(True)
        
        # Update splitter sizes for better visibility
        total_width = self.search_splitter.width()
        self.search_splitter.setSizes([int(total_width * 0.4), int(total_width * 0.6)])
        
        # Give focus to the context list
        self.context_list.setFocus()
        
        # Update status bar
        self.statusBar().showMessage("Viewing document in context. Use arrow keys to navigate, Enter to select, Right arrow to exit", 5000)
    
    def close_document_context(self):
        """Close the document context view."""
        # Hide the context frame
        self.context_frame.setVisible(False)
        
        # Reset visual effects
        self.results_list.setEnabled(True)
        self.results_list.setStyleSheet("")
        
        # Update splitter sizes
        self.search_splitter.setSizes([0, self.search_splitter.width()])
        
        # Return focus to the main results list
        self.results_list.setFocus()
        
        # Update status bar
        self.statusBar().showMessage("Returned to search results", 3000)
    
    def on_context_item_activated(self, item: QListWidgetItem):
        """Handle item activation from the context list."""
        # Get document info
        path = item.data(Qt.ItemDataRole.UserRole)
        if not path:
            return
            
        # Use regular activation logic - same as on_item_activated
        use_cursor_mode = self.cursor_mode_action.isChecked()
        self._process_item(path, use_cursor_mode)
            
        # Keep context view open, just show status message
        self.statusBar().showMessage(f"Document sent to target. Use right arrow to exit context view.", 3000)
        
        # Return focus to the context list
        self.context_list.setFocus()
    
    def on_context_ctrl_enter_activated(self, item: QListWidgetItem):
        """Handle Ctrl+Enter activation from the context list."""
        # Get document info
        path = item.data(Qt.ItemDataRole.UserRole)
        if not path:
            return
            
        # Use alternate paste mode - same as on_ctrl_enter_activated
        use_cursor_mode = not self.cursor_mode_action.isChecked()
        self._process_item(path, use_cursor_mode)
            
        # Keep context view open, just show status message
        self.statusBar().showMessage(f"Document sent to target. Use right arrow to exit context view.", 3000)
        
        # Return focus to the context list
        self.context_list.setFocus()

    def _process_item(self, file_path: str, use_cursor_mode: bool):
        """Process a document with the specified paste mode."""
        success = False
        
        if self.active_target_id:
            # Set paste mode based on the provided mode flag
            paste_mode = PasteMode.CURSOR if use_cursor_mode else PasteMode.END
            
            # Paste to active document with selected mode
            success = self.searcher.word_handler.paste_to_active_document(
                file_path,
                self.active_target_id,
                mode=paste_mode
            )
            
            mode_str = "cursor position" if paste_mode == PasteMode.CURSOR else "document end"
            mode_type = " (default)" if use_cursor_mode == self.cursor_mode_action.isChecked() else " (alternate)"
            status_msg = (
                f"Pasted '{Path(file_path).name}' at {mode_str}{mode_type}"
                if success
                else f"Error pasting to active document at {mode_str}"
            )
            
        elif self.target_document:
            # Use existing file target logic
            success = self.searcher.word_handler.transfer_content(
                file_path,
                self.target_document
            )
            status_msg = (
                f"Transferred '{Path(file_path).name}' to '{Path(self.target_document).name}'"
                if success
                else "Error transferring content. Check target document."
            )
            
        else:
            # Clipboard mode
            success = self.searcher.word_handler.copy_to_clipboard(file_path)
            status_msg = (
                f"Copied '{Path(file_path).name}' to clipboard"
                if success
                else "Error copying to clipboard"
            )
        
        self.statusBar().showMessage(status_msg, 3000)
        
    def _update_target_status(self):
        """Update the target document status display with enhanced visibility."""
        if self.active_target_id:
            self.target_status.setText("Target: [Active Document]")
            self.target_status.setStyleSheet("""
                QLineEdit {
                    background-color: #e6f3ff;
                    color: #000000;
                    padding: 2px 5px;
                    border: 1px solid #b8d6f3;
                }
            """)
        elif self.target_document:
            target_name = Path(self.target_document).name
            self.target_status.setText(f"Target: {target_name}")
            self.target_status.setStyleSheet("""
                QLineEdit {
                    background-color: #e6ffe6;
                    color: #000000;
                    padding: 2px 5px;
                    border: 1px solid #b8f3b8;
                }
            """)
        else:
            self.target_status.clear()
            self.target_status.setPlaceholderText("No target document selected (using clipboard)")
            self.target_status.setStyleSheet("""
                QLineEdit {
                    background-color: #ffffff;
                    color: #666666;
                    padding: 2px 5px;
                    border: 1px solid #cccccc;
                }
                QLineEdit::placeholder {
                    color: #999999;
                }
            """)
    
    def refresh_open_documents(self):
        """Update the list of open documents in the menu."""
        # Clear existing document actions
        for action in self.open_docs_menu.actions()[2:]:  # Skip refresh and separator
            self.open_docs_menu.removeAction(action)
        
        # Get current open documents
        active_docs = self.searcher.word_handler.get_active_documents()
        
        if not active_docs:
            no_docs_action = self.open_docs_menu.addAction('No Open Documents')
            no_docs_action.setEnabled(False)
            return
        
        # Add action for each open document
        for doc in active_docs:
            action = self.open_docs_menu.addAction(doc.name)
            action.setData(doc.doc_id)
            action.triggered.connect(lambda checked, d=doc: self.set_active_target(d))
    
    def set_active_target(self, doc: ActiveDocument):
        """Set an open document as the paste target."""
        self.target_document = None  # Clear file target
        self.active_target_id = doc.doc_id
        self._update_target_status()
        self.statusBar().showMessage(f"Set active target to: {doc.name}", 3000)

        # Ensure screen updating is restored for the active document
        try:
            word_app = win32com.client.GetActiveObject("Word.Application")
            word_app.ScreenUpdating = True
        except:
            pass

    def select_target_document(self):
        """Open file dialog for selecting target document."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Target Document",
            self.search_folder,
            "Word Documents (*.docx)"
        )
        
        if file_path:
            try:
                # Validate document
                with self.searcher.word_handler.word_session() as word_app:
                    with self.searcher.word_handler.open_document(word_app, file_path):
                        pass
                    word_app.ScreenUpdating = True

                self.active_target_id = None  # Clear active document target
                self.target_document = file_path
                self.settings.setValue('target_document', file_path)
                self._update_target_status()
                self.statusBar().showMessage(f"Target document set: {Path(file_path).name}", 3000)
                
            except Exception as e:
                QMessageBox.warning(
                    self,
                    "Invalid Target Document",
                    f"Could not use selected document as target: {str(e)}"
                )
    
    def clear_target_document(self):
        """Clear target document setting."""
        if self.target_document or self.active_target_id:
            reply = QMessageBox.question(
                self,
                "Clear Target Document",
                "Are you sure you want to clear the target document?\n"
                "Content will be copied to clipboard instead.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                self.target_document = None
                self.active_target_id = None
                self.settings.setValue('target_document', None)
                self._update_target_status()
                self.statusBar().showMessage("Target document cleared", 3000)
    
    def show_target_document(self):
        """Display current target document information."""
        if self.active_target_id:
            QMessageBox.information(
                self,
                "Target Document",
                "Currently targeting an open document.\n"
                "Content will be pasted at the cursor position."
            )
        elif self.target_document:
            target_path = Path(self.target_document)
            try:
                modified_time = target_path.stat().st_mtime
                modified_str = datetime.fromtimestamp(modified_time).strftime('%Y-%m-%d %H:%M:%S')
                
                QMessageBox.information(
                    self,
                    "Target Document",
                    f"Current target document:\n"
                    f"Name: {target_path.name}\n"
                    f"Path: {target_path}\n"
                    f"Last modified: {modified_str}"
                )
            except Exception as e:
                QMessageBox.warning(
                    self,
                    "Target Document Error",
                    f"Error accessing target document:\n{str(e)}\n\n"
                    "You may want to clear and reselect the target document."
                )
        else:
            QMessageBox.information(
                self,
                "Target Document",
                "No target document set.\n"
                "Content will be copied to clipboard."
            )
    
    def index_documents(self):
        """Update document index and UI using multithreading."""
        # Create a worker thread to perform the indexing
        class IndexWorker(QThread):
            indexing_complete = pyqtSignal(int)  # Signal to emit when done
            progress_update = pyqtSignal(int, int)  # current, total
            error_occurred = pyqtSignal(str)  # Signal for error reporting
            
            def __init__(self, searcher):
                super().__init__()
                self.searcher = searcher
                
            def run(self):
                try:
                    self.searcher.index_documents(lambda current, total: self.progress_update.emit(current, total))
                    self.indexing_complete.emit(len(self.searcher.document_index))
                except Exception as e:
                    print(f"Error in indexing thread: {e}")
                    import traceback
                    traceback.print_exc()
                    self.error_occurred.emit(str(e))
        
        # Status bar message for progress updates
        self.statusBar().showMessage("Building document index...")
        
        # Create and start the worker thread
        self.index_worker = IndexWorker(self.searcher)
        self.index_worker.progress_update.connect(self._on_index_progress)
        self.index_worker.indexing_complete.connect(self._on_indexing_complete)
        self.index_worker.error_occurred.connect(self._on_indexing_error)
        self.index_worker.start()
    
    def _on_index_progress(self, current, total):
        """Update status bar with indexing progress."""
        if total > 0:
            percent = int(current/total*100)
            self.statusBar().showMessage(f"Indexing documents: {current}/{total} ({percent}%)")
    
    def _on_indexing_complete(self, doc_count):
        """Handle completion of document indexing."""
        self.statusBar().showMessage(f"Indexed {doc_count} documents")
        
        # Clean up the worker thread
        if hasattr(self, 'index_worker'):
            self.index_worker.deleteLater()
            
    def _on_indexing_error(self, error_msg):
        """Handle errors during indexing."""
        self.statusBar().showMessage(f"Error during indexing: {error_msg[:50]}...", 5000)
        
        # Show error dialog
        QMessageBox.critical(
            self,
            "Indexing Error",
            f"An error occurred while indexing documents:\n\n{error_msg}"
        )
        
        # Clean up worker thread
        if hasattr(self, 'index_worker'):
            self.index_worker.deleteLater()
    
    def select_search_folder(self):
        """Open folder selection dialog."""
        folder = QFileDialog.getExistingDirectory(
            self,
            "Select Folder to Search",
            self.search_folder,
            QFileDialog.Option.ShowDirsOnly
        )
        
        if folder:
            self.search_folder = folder
            self.settings.setValue('search_folder', folder)
            self.search_input.setPlaceholderText(f"Type to search documents in: {self.search_folder}")
            self.searcher = DocumentSearcher(self.search_folder, self.prefix_manager)
            self.index_documents()
            
            if self.search_input.text():
                self.perform_search()
    
    def show_current_folder(self):
        """Display current search folder information."""
        QMessageBox.information(
            self,
            "Current Search Folder",
            f"Currently searching in:\n{self.search_folder}\n\n"
            f"Number of indexed documents: {len(self.searcher.document_index)}"
        )
    
    def reindex_documents(self):
        """Reindex the currently selected search folder."""
        self.index_documents()
        
        # Show brief confirmation in status bar
        self.statusBar().showMessage(f"Reindexing completed. Found {len(self.searcher.document_index)} documents.", 3000)
    
    def on_search_text_changed(self, text: str):
        """Handle search input changes with intelligent debouncing."""
        # Close context view if it's open
        if self.context_frame.isVisible():
            self.close_document_context()
            
        self.search_timer.stop()
        self.search_timer.start(self.search_delay)
    
    def perform_search(self):
        """Execute search operation with sophisticated result management."""
        query = self.search_input.text()
        
        # Store current selection state before updating
        current_selected_path = None
        current_item = self.results_list.currentItem()
        if current_item:
            current_selected_path = current_item.data(Qt.ItemDataRole.UserRole)
        
        # Cache focus state
        had_focus = self.results_list.hasFocus()
        
        # Clear results with minimal visual disruption
        self.results_list.clear()
        
        # Determine current sort configuration
        sort_key = None
        for action in self.sort_actions.values():
            if action.isChecked():
                sort_key = action.data()
                break
        
        reverse = self.reverse_sort_action.isChecked()
        
        # Get include_path setting
        include_path = self.include_path_action.isChecked()
        
        # Perform search with current parameters
        results = self.searcher.search(query, sort_key, reverse, include_path)
        
        # Efficiently populate results with intelligent selection management
        selection_restored = False
        first_item = None
        
        # Batch update for better performance
        self.results_list.setUpdatesEnabled(False)
        try:
            for doc in results:
                item = SearchResultItem(doc)  # Use our custom result item
                self.results_list.addItem(item)
                
                # Track first item for default selection
                if first_item is None:
                    first_item = item
                
                # Attempt to restore previous selection
                if current_selected_path and str(doc.path) == current_selected_path:
                    self.results_list.setCurrentItem(item)
                    selection_restored = True
        finally:
            self.results_list.setUpdatesEnabled(True)
        
        # Handle selection state
        if not selection_restored and first_item:
            self.results_list.setCurrentItem(first_item)
            self.results_list.scrollToItem(
                first_item,
                QListWidget.ScrollHint.PositionAtTop
            )
        
        # Restore focus if needed
        if had_focus:
            self.results_list.setFocus()
        
        # Update status with result count
        self.statusBar().showMessage(
            f"Found {len(results)} matching documents"
        )

    def on_item_activated(self, item: QListWidgetItem):
        """Handle document selection with intelligent content transfer."""
        file_path = item.data(Qt.ItemDataRole.UserRole)
        success = False
        
        if self.active_target_id:
            # Determine paste mode from menu state
            paste_mode = (PasteMode.CURSOR if self.cursor_mode_action.isChecked() 
                         else PasteMode.END)
            
            # Paste to active document with selected mode
            success = self.searcher.word_handler.paste_to_active_document(
                file_path,
                self.active_target_id,
                mode=paste_mode
            )
            
            mode_str = "cursor position" if paste_mode == PasteMode.CURSOR else "document end"
            status_msg = (
                f"Pasted '{Path(file_path).name}' at {mode_str}"
                if success
                else f"Error pasting to active document at {mode_str}"
            )
            
        elif self.target_document:
            # Use existing file target logic
            success = self.searcher.word_handler.transfer_content(
                file_path,
                self.target_document
            )
            status_msg = (
                f"Transferred '{Path(file_path).name}' to '{Path(self.target_document).name}'"
                if success
                else "Error transferring content. Check target document."
            )
            
        else:
            # Clipboard mode
            success = self.searcher.word_handler.copy_to_clipboard(file_path)
            status_msg = (
                f"Copied '{Path(file_path).name}' to clipboard"
                if success
                else "Error copying to clipboard"
            )
        
        self.statusBar().showMessage(status_msg, 3000)

    def show_prefix_manager(self):
        """Show the prefix configuration dialog."""
        dialog = PrefixManagerDialog(self.prefix_manager, self.search_folder, self)
        dialog.exec()
        
        # After dialog closes, verify all folders still exist
        missing = self.prefix_manager.verify_folders_exist(self.search_folder)
        if missing:
            message = "The following prefix mappings have missing folders:\n\n"
            for prefix, folder in missing:
                message += f"Prefix '{prefix}' -> folder '{folder}'\n"
            message += "\nPlease update or remove these mappings."
            
            QMessageBox.warning(
                self,
                "Missing Folders",
                message
            )
    
    def import_prefixes(self):
        """Import prefix configurations from CSV."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Import Prefix Configuration",
            "",
            "CSV Files (*.csv)"
        )
        
        if file_path:
            if self.prefix_manager.import_from_csv(file_path):
                QMessageBox.information(
                    self,
                    "Import Successful",
                    "Prefix configurations have been imported successfully."
                )
            else:
                QMessageBox.warning(
                    self,
                    "Import Failed",
                    "Failed to import prefix configurations.\n"
                    "Please check the file format and try again."
                )
    
    def export_prefixes(self):
        """Export prefix configurations to CSV."""
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Prefix Configuration",
            "",
            "CSV Files (*.csv)"
        )
        
        if file_path:
            if not file_path.lower().endswith('.csv'):
                file_path += '.csv'
                
            if self.prefix_manager.export_to_csv(file_path):
                QMessageBox.information(
                    self,
                    "Export Successful",
                    "Prefix configurations have been exported successfully."
                )
            else:
                QMessageBox.warning(
                    self,
                    "Export Failed",
                    "Failed to export prefix configurations.\n"
                    "Please check file permissions and try again."
                )

def main():
    """
    Application entry point with sophisticated initialization.
    
    This implementation provides:
    1. Proper system integration
    2. Resource management
    3. Error handling
    4. System tray support
    """
    try:
        app = QApplication(sys.argv)
        
        # Prevent application exit when last window closes
        app.setQuitOnLastWindowClosed(False)
        
        # Apply Fusion style for consistent cross-platform appearance
        app.setStyle('Fusion')
        
        window = DocxSearchApp()
        
        # Enter Qt event loop with proper system integration
        sys.exit(app.exec())
        
    except Exception as e:
        print(f"Critical error during application startup: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()